{"tasks":{"1":{"id":"1","description":"Implement Control Message Queue Infrastructure","status":"pending","dependencies":[],"started_at":null,"completed_at":null,"claimed_by":null,"timeout_seconds":600,"instructions":"**Files:**\n- Create: `lib/control-message-queue.ts`\n- Test: `test/38_control_message_queue.js`\n\n**Context:** Per W3C spec, codec methods like `configure()`, `encode()`, `decode()` must enqueue control messages rather than execute immediately. This ensures non-blocking behavior and proper ordering.\n\n**Step 1: Write the failing test**\n\nCreate `test/38_control_message_queue.js`:\n```javascript\n'use strict';\n\nconst assert = require('assert');\n\n// Test control message queue ordering and async execution\nconsole.log('[TEST] Control message queue infrastructure');\n\nconst { ControlMessageQueue } = require('../lib/control-message-queue');\n\nasync function testQueueOrdering() {\n    const results = [];\n    const queue = new ControlMessageQueue();\n\n    // Enqueue messages that record execution order\n    queue.enqueue(() => {\n        results.push('first');\n        return Promise.resolve();\n    });\n    queue.enqueue(() => {\n        results.push('second');\n        return Promise.resolve();\n    });\n    queue.enqueue(() => {\n        results.push('third');\n        return Promise.resolve();\n    });\n\n    // Wait for all to process\n    await queue.flush();\n\n    assert.deepStrictEqual(results, ['first', 'second', 'third'],\n        'Messages should execute in FIFO order');\n    console.log('[PASS] Queue maintains FIFO order');\n}\n\nasync function testAsyncExecution() {\n    const queue = new ControlMessageQueue();\n    let executed = false;\n\n    queue.enqueue(async () => {\n        await new Promise(r => setTimeout(r, 10));\n        executed = true;\n    });\n\n    // Should not block\n    assert.strictEqual(executed, false, 'Should not execute synchronously');\n\n    await queue.flush();\n    assert.strictEqual(executed, true, 'Should execute after flush');\n    console.log('[PASS] Messages execute asynchronously');\n}\n\nasync function testErrorHandling() {\n    const queue = new ControlMessageQueue();\n    let errorCaught = false;\n\n    queue.setErrorHandler((err) => {\n        errorCaught = true;\n        console.log(`[EXPECTED ERROR] ${err.message}`);\n    });\n\n    queue.enqueue(() => {\n        throw new Error('Test error');\n    });\n\n    await queue.flush();\n    assert.strictEqual(errorCaught, true, 'Error handler should be called');\n    console.log('[PASS] Error handling works');\n}\n\n(async () => {\n    await testQueueOrdering();\n    await testAsyncExecution();\n    await testErrorHandling();\n    console.log('[PASS] Control message queue infrastructure verified');\n})().catch(e => {\n    console.error('[FAIL]', e.message);\n    process.exit(1);\n});\n```\n\n**Step 2: Run test to verify it fails**\n\n```bash\nnode test/38_control_message_queue.js\n```\n\nExpected: FAIL - module doesn't exist\n\n**Step 3: Create lib/control-message-queue.ts**\n\n```typescript\n/**\n * Control Message Queue per W3C WebCodecs spec.\n *\n * Each codec instance maintains an internal [[control message queue]].\n * Methods like configure(), encode(), decode() enqueue control messages\n * rather than executing immediately, ensuring non-blocking behavior.\n */\n\ntype ControlMessage = () => void | Promise<void>;\n\nexport class ControlMessageQueue {\n    private queue: ControlMessage[] = [];\n    private processing: boolean = false;\n    private errorHandler: ((error: Error) => void) | null = null;\n\n    /**\n     * Enqueue a control message for async processing.\n     * Messages are processed in FIFO order.\n     */\n    enqueue(message: ControlMessage): void {\n        this.queue.push(message);\n        this.scheduleProcessing();\n    }\n\n    /**\n     * Set error handler for message processing failures.\n     */\n    setErrorHandler(handler: (error: Error) => void): void {\n        this.errorHandler = handler;\n    }\n\n    /**\n     * Wait for all queued messages to be processed.\n     */\n    async flush(): Promise<void> {\n        while (this.queue.length > 0 || this.processing) {\n            await new Promise(resolve => queueMicrotask(resolve));\n        }\n    }\n\n    /**\n     * Clear all pending messages (used by reset/close).\n     */\n    clear(): void {\n        this.queue = [];\n    }\n\n    /**\n     * Get current queue size.\n     */\n    get size(): number {\n        return this.queue.length;\n    }\n\n    private scheduleProcessing(): void {\n        if (this.processing) return;\n\n        queueMicrotask(() => this.processNext());\n    }\n\n    private async processNext(): Promise<void> {\n        if (this.processing || this.queue.length === 0) return;\n\n        this.processing = true;\n        const message = this.queue.shift()!;\n\n        try {\n            await message();\n        } catch (error) {\n            if (this.errorHandler) {\n                this.errorHandler(error as Error);\n            } else {\n                console.error('Unhandled control message error:', error);\n            }\n        }\n\n        this.processing = false;\n\n        // Continue processing if more messages\n        if (this.queue.length > 0) {\n            this.scheduleProcessing();\n        }\n    }\n}\n```\n\n**Step 4: Build TypeScript and run test**\n\n```bash\nnpm run build:ts && node test/38_control_message_queue.js\n```\n\nExpected: PASS\n\n**Step 5: Commit**\n\n```bash\ngit add lib/control-message-queue.ts test/38_control_message_queue.js\ngit commit -m \"feat(core): implement control message queue per W3C spec\"\n```\n\n---","role":null},"2":{"id":"2","description":"Implement Codec Saturation Tracking","status":"pending","dependencies":[],"started_at":null,"completed_at":null,"claimed_by":null,"timeout_seconds":600,"instructions":"**Files:**\n- Modify: `src/video_encoder.h` (add saturation flag and signaling)\n- Modify: `src/video_encoder.cc` (implement saturation logic)\n- Modify: `src/async_encode_worker.h` (add saturation callback)\n- Test: `test/39_codec_saturation.js`\n\n**Context:** Per W3C spec, `[[codec saturated]]` is a boolean indicating when the underlying codec implementation cannot accept more work. During saturation, encode/decode calls are buffered, incrementing queue size.\n\n**Step 1: Write the failing test**\n\nCreate `test/39_codec_saturation.js`:\n```javascript\n'use strict';\n\nconst assert = require('assert');\nconst { VideoEncoder, VideoFrame } = require('../lib');\n\nasync function testCodecSaturation() {\n    console.log('[TEST] Codec saturation tracking');\n\n    const chunks = [];\n    let maxQueueSize = 0;\n\n    const encoder = new VideoEncoder({\n        output: (chunk) => {\n            chunks.push(chunk);\n        },\n        error: (e) => console.error(`[ERR] ${e.message}`)\n    });\n\n    encoder.configure({\n        codec: 'avc1.42001E',\n        width: 320,\n        height: 240,\n        bitrate: 1000000\n    });\n\n    // Rapidly enqueue many frames to trigger saturation\n    const frameData = Buffer.alloc(320 * 240 * 4);\n    const frames = [];\n\n    for (let i = 0; i < 30; i++) {\n        const frame = new VideoFrame(frameData, {\n            codedWidth: 320,\n            codedHeight: 240,\n            timestamp: i * 33333\n        });\n        frames.push(frame);\n    }\n\n    // Enqueue all frames rapidly\n    for (let i = 0; i < frames.length; i++) {\n        encoder.encode(frames[i], { keyFrame: i === 0 });\n        // Track max queue size during encoding\n        if (encoder.encodeQueueSize > maxQueueSize) {\n            maxQueueSize = encoder.encodeQueueSize;\n        }\n    }\n\n    console.log(`Max queue size during encoding: ${maxQueueSize}`);\n\n    // Queue should have grown during rapid encoding\n    assert.ok(maxQueueSize > 0, 'Queue size should increase during rapid encoding');\n\n    await encoder.flush();\n\n    // After flush, queue should be empty\n    assert.strictEqual(encoder.encodeQueueSize, 0, 'Queue should be empty after flush');\n\n    // Close frames\n    frames.forEach(f => f.close());\n    encoder.close();\n\n    console.log(`[PASS] Codec saturation: max queue=${maxQueueSize}, chunks=${chunks.length}`);\n}\n\ntestCodecSaturation().catch(e => {\n    console.error('[FAIL]', e.message);\n    process.exit(1);\n});\n```\n\n**Step 2: Run test to check current behavior**\n\n```bash\nnode test/39_codec_saturation.js\n```\n\nNote current queue size behavior.\n\n**Step 3: Add saturation tracking to src/video_encoder.h**\n\nAdd after `encode_queue_size_` field:\n```cpp\n  std::atomic<bool> codec_saturated_{false};\n  static constexpr size_t kMaxQueueSize = 16;  // Saturation threshold\n\n  // Saturation status accessor\n  bool IsCodecSaturated() const { return codec_saturated_.load(); }\n```\n\n**Step 4: Update src/video_encoder.cc Encode method**\n\nAdd saturation check in Encode:\n```cpp\nvoid VideoEncoder::Encode(const Napi::CallbackInfo& info) {\n    // ... existing validation ...\n\n    // Check saturation before accepting more work\n    if (async_mode_ && async_worker_) {\n        size_t current_queue = async_worker_->QueueSize();\n        codec_saturated_.store(current_queue >= kMaxQueueSize);\n\n        if (codec_saturated_.load()) {\n            // Still accept the frame but increment queue counter\n            // The queue will buffer it\n        }\n    }\n\n    encode_queue_size_++;\n\n    // ... rest of encode logic ...\n}\n```\n\n**Step 5: Add GetCodecSaturated accessor**\n\n```cpp\nNapi::Value VideoEncoder::GetCodecSaturated(const Napi::CallbackInfo& info) {\n    return Napi::Boolean::New(info.Env(), codec_saturated_.load());\n}\n```\n\nRegister in Init:\n```cpp\nInstanceAccessor(\"codecSaturated\", &VideoEncoder::GetCodecSaturated, nullptr),\n```\n\n**Step 6: Build and run test**\n\n```bash\nnpm run build:native && node test/39_codec_saturation.js\n```\n\nExpected: PASS\n\n**Step 7: Commit**\n\n```bash\ngit add src/video_encoder.h src/video_encoder.cc test/39_codec_saturation.js\ngit commit -m \"feat(encoder): implement codec saturation tracking per W3C spec\"\n```\n\n---","role":null},"3":{"id":"3","description":"Add Complete Type Definitions","status":"pending","dependencies":[],"started_at":null,"completed_at":null,"claimed_by":null,"timeout_seconds":600,"instructions":"**Files:**\n- Modify: `lib/types.ts`\n- Test: `test/40_type_definitions.js`\n\n**Context:** Add all missing W3C WebCodecs type definitions including ImageDecoder types, VideoFrameMetadata, hardware acceleration, and enhanced config options.\n\n**Step 1: Write the failing test**\n\nCreate `test/40_type_definitions.js`:\n```javascript\n'use strict';\n\nconst assert = require('assert');\n\nconsole.log('[TEST] Complete type definitions');\n\n// Runtime validation of type structures\nconst validVideoEncoderConfig = {\n    codec: 'avc1.42001E',\n    width: 640,\n    height: 480,\n    hardwareAcceleration: 'prefer-software',\n    latencyMode: 'realtime',\n    bitrateMode: 'variable',\n    alpha: 'discard',\n    scalabilityMode: 'L1T1'\n};\n\nconst validVideoDecoderConfig = {\n    codec: 'avc1.42001E',\n    hardwareAcceleration: 'no-preference',\n    optimizeForLatency: true,\n    rotation: 90,\n    flip: false\n};\n\nconst validVideoFrameInit = {\n    codedWidth: 640,\n    codedHeight: 480,\n    timestamp: 0,\n    rotation: 180,\n    flip: true,\n    visibleRect: { x: 0, y: 0, width: 640, height: 480 }\n};\n\n// Validate structure exists\nassert.ok(typeof validVideoEncoderConfig.hardwareAcceleration === 'string');\nassert.ok(typeof validVideoDecoderConfig.rotation === 'number');\nassert.ok(typeof validVideoFrameInit.flip === 'boolean');\n\nconsole.log('[PASS] Type definitions verified');\n```\n\n**Step 2: Run test**\n\n```bash\nnode test/40_type_definitions.js\n```\n\nExpected: PASS (runtime test)\n\n**Step 3: Update lib/types.ts with complete definitions**\n\nReplace/enhance the types file:\n```typescript\n// Hardware acceleration hint\nexport type HardwareAcceleration = 'no-preference' | 'prefer-hardware' | 'prefer-software';\n\n// Alpha handling\nexport type AlphaOption = 'keep' | 'discard';\n\n// Latency mode\nexport type LatencyMode = 'quality' | 'realtime';\n\n// Bitrate mode\nexport type VideoEncoderBitrateMode = 'constant' | 'variable' | 'quantizer';\n\nexport interface VideoEncoderConfig {\n    codec: string;\n    width: number;\n    height: number;\n    bitrate?: number;\n    framerate?: number;\n    hardwareAcceleration?: HardwareAcceleration;\n    latencyMode?: LatencyMode;\n    bitrateMode?: VideoEncoderBitrateMode;\n    alpha?: AlphaOption;\n    scalabilityMode?: string;\n    displayAspectWidth?: number;\n    displayAspectHeight?: number;\n    contentHint?: string;\n}\n\nexport interface VideoDecoderConfig {\n    codec: string;\n    codedWidth?: number;\n    codedHeight?: number;\n    description?: ArrayBuffer | ArrayBufferView;\n    colorSpace?: VideoColorSpaceInit;\n    hardwareAcceleration?: HardwareAcceleration;\n    optimizeForLatency?: boolean;\n    displayAspectWidth?: number;\n    displayAspectHeight?: number;\n    rotation?: 0 | 90 | 180 | 270;\n    flip?: boolean;\n}\n\nexport interface VideoFrameInit {\n    codedWidth: number;\n    codedHeight: number;\n    timestamp: number;\n    duration?: number;\n    displayWidth?: number;\n    displayHeight?: number;\n    format?: VideoPixelFormat;\n    rotation?: 0 | 90 | 180 | 270;\n    flip?: boolean;\n    visibleRect?: { x: number; y: number; width: number; height: number };\n    colorSpace?: VideoColorSpaceInit;\n}\n\nexport interface VideoFrameMetadata {\n    captureTime?: DOMHighResTimeStamp;\n    receiveTime?: DOMHighResTimeStamp;\n    rtpTimestamp?: number;\n}\n\nexport type DOMHighResTimeStamp = number;\n\n// ImageDecoder types\nexport interface ImageDecodeOptions {\n    frameIndex?: number;\n    completeFramesOnly?: boolean;\n}\n\nexport interface ImageDecodeResult {\n    image: any; // VideoFrame\n    complete: boolean;\n}\n\nexport interface ImageDecoderInit {\n    type: string;\n    data: ReadableStream<Uint8Array> | BufferSource;\n    colorSpaceConversion?: 'default' | 'none';\n    desiredWidth?: number;\n    desiredHeight?: number;\n    preferAnimation?: boolean;\n}\n\nexport interface ImageTrack {\n    readonly animated: boolean;\n    readonly frameCount: number;\n    readonly repetitionCount: number;\n    selected: boolean;\n}\n\nexport interface ImageTrackList {\n    readonly length: number;\n    readonly selectedIndex: number;\n    readonly selectedTrack: ImageTrack | null;\n    readonly ready: Promise<void>;\n    [index: number]: ImageTrack;\n}\n\n// Encoder metadata\nexport interface EncodedVideoChunkMetadata {\n    decoderConfig?: VideoDecoderConfig & {\n        description?: ArrayBuffer;\n    };\n    svc?: {\n        temporalLayerId: number;\n    };\n    alphaSideData?: BufferSource;\n}\n\nexport interface EncodedAudioChunkMetadata {\n    decoderConfig?: AudioDecoderConfig & {\n        description?: ArrayBuffer;\n    };\n}\n```\n\n**Step 4: Build and run test**\n\n```bash\nnpm run build:ts && node test/40_type_definitions.js\n```\n\nExpected: PASS\n\n**Step 5: Commit**\n\n```bash\ngit add lib/types.ts test/40_type_definitions.js\ngit commit -m \"feat(types): add complete W3C WebCodecs type definitions\"\n```\n\n---","role":null},"4":{"id":"4","description":"Integrate Control Queue into VideoEncoder with ondequeue","status":"pending","dependencies":["1","2","3"],"started_at":null,"completed_at":null,"claimed_by":null,"timeout_seconds":600,"instructions":"**Files:**\n- Modify: `lib/index.ts` (VideoEncoder class)\n- Test: `test/41_videoencoder_queue.js`\n\n**Context:** Integrate the control message queue into VideoEncoder, ensuring encode() enqueues messages and ondequeue fires when queue size decreases.\n\n**Step 1: Write the failing test**\n\nCreate `test/41_videoencoder_queue.js`:\n```javascript\n'use strict';\n\nconst assert = require('assert');\nconst { VideoEncoder, VideoFrame } = require('../lib');\n\nasync function testVideoEncoderQueue() {\n    console.log('[TEST] VideoEncoder control queue + ondequeue');\n\n    let dequeueCount = 0;\n    let maxQueueSize = 0;\n    const chunks = [];\n\n    const encoder = new VideoEncoder({\n        output: (chunk, metadata) => {\n            chunks.push(chunk);\n        },\n        error: (e) => console.error(`[ERR] ${e.message}`)\n    });\n\n    encoder.ondequeue = () => {\n        dequeueCount++;\n    };\n\n    encoder.configure({\n        codec: 'avc1.42001E',\n        width: 64,\n        height: 64,\n        bitrate: 100000\n    });\n\n    const frameData = Buffer.alloc(64 * 64 * 4);\n\n    // Encode multiple frames\n    for (let i = 0; i < 5; i++) {\n        const frame = new VideoFrame(frameData, {\n            codedWidth: 64,\n            codedHeight: 64,\n            timestamp: i * 33333\n        });\n        encoder.encode(frame, { keyFrame: i === 0 });\n\n        if (encoder.encodeQueueSize > maxQueueSize) {\n            maxQueueSize = encoder.encodeQueueSize;\n        }\n\n        frame.close();\n    }\n\n    await encoder.flush();\n    encoder.close();\n\n    console.log(`Results: dequeueCount=${dequeueCount}, maxQueue=${maxQueueSize}, chunks=${chunks.length}`);\n\n    assert.ok(dequeueCount >= 1, `ondequeue should fire at least once, got ${dequeueCount}`);\n    assert.ok(chunks.length >= 1, `Should produce chunks, got ${chunks.length}`);\n\n    console.log('[PASS] VideoEncoder control queue + ondequeue works');\n}\n\ntestVideoEncoderQueue().catch(e => {\n    console.error('[FAIL]', e.message);\n    process.exit(1);\n});\n```\n\n**Step 2: Run test to verify it fails**\n\n```bash\nnode test/41_videoencoder_queue.js\n```\n\nExpected: FAIL - ondequeue doesn't fire (dequeueCount = 0)\n\n**Step 3: Update VideoEncoder in lib/index.ts**\n\n```typescript\nimport { ControlMessageQueue } from './control-message-queue';\n\nexport class VideoEncoder {\n    private _native: any;\n    private _state: CodecState = 'unconfigured';\n    private _ondequeue: (() => void) | null = null;\n    private _controlQueue: ControlMessageQueue;\n    private _encodeQueueSize: number = 0;\n\n    constructor(init: VideoEncoderInit) {\n        this._controlQueue = new ControlMessageQueue();\n        this._controlQueue.setErrorHandler(init.error);\n\n        this._native = new native.VideoEncoder({\n            output: (chunk: any, metadata: any) => {\n                // Decrement queue size when output received\n                this._encodeQueueSize = Math.max(0, this._encodeQueueSize - 1);\n\n                const wrappedChunk = new EncodedVideoChunk({\n                    type: chunk.type,\n                    timestamp: chunk.timestamp,\n                    duration: chunk.duration,\n                    data: chunk.data\n                });\n                init.output(wrappedChunk, metadata);\n\n                // Fire ondequeue after output\n                this._triggerDequeue();\n            },\n            error: init.error\n        });\n    }\n\n    get state(): CodecState {\n        return this._native.state;\n    }\n\n    get encodeQueueSize(): number {\n        return this._encodeQueueSize;\n    }\n\n    get ondequeue(): (() => void) | null {\n        return this._ondequeue;\n    }\n\n    set ondequeue(handler: (() => void) | null) {\n        this._ondequeue = handler;\n    }\n\n    private _triggerDequeue(): void {\n        if (this._ondequeue) {\n            queueMicrotask(() => {\n                if (this._ondequeue) {\n                    this._ondequeue();\n                }\n            });\n        }\n    }\n\n    configure(config: VideoEncoderConfig): void {\n        // Validate displayAspect pairing\n        if ((config.displayAspectWidth !== undefined) !==\n            (config.displayAspectHeight !== undefined)) {\n            throw new TypeError(\n                'displayAspectWidth and displayAspectHeight must both be present or both absent'\n            );\n        }\n\n        this._controlQueue.enqueue(() => {\n            this._native.configure(config);\n        });\n    }\n\n    encode(frame: VideoFrame, options?: { keyFrame?: boolean }): void {\n        this._encodeQueueSize++;\n\n        this._controlQueue.enqueue(() => {\n            this._native.encode(frame._nativeFrame, options || {});\n        });\n    }\n\n    async flush(): Promise<void> {\n        await this._controlQueue.flush();\n        return new Promise((resolve) => {\n            this._native.flush();\n            resolve();\n        });\n    }\n\n    reset(): void {\n        this._controlQueue.clear();\n        this._encodeQueueSize = 0;\n        this._native.reset();\n    }\n\n    close(): void {\n        this._controlQueue.clear();\n        this._native.close();\n    }\n\n    static async isConfigSupported(config: VideoEncoderConfig): Promise<{\n        supported: boolean;\n        config: VideoEncoderConfig;\n    }> {\n        return native.VideoEncoder.isConfigSupported(config);\n    }\n}\n```\n\n**Step 4: Build and run test**\n\n```bash\nnpm run build:ts && node test/41_videoencoder_queue.js\n```\n\nExpected: PASS\n\n**Step 5: Commit**\n\n```bash\ngit add lib/index.ts test/41_videoencoder_queue.js\ngit commit -m \"feat(videoencoder): integrate control queue and ondequeue event\"\n```\n\n---","role":null},"5":{"id":"5","description":"Integrate Control Queue into VideoDecoder with ondequeue","status":"pending","dependencies":["1","2","3"],"started_at":null,"completed_at":null,"claimed_by":null,"timeout_seconds":600,"instructions":"**Files:**\n- Modify: `lib/index.ts` (VideoDecoder class)\n- Test: `test/42_videodecoder_queue.js`\n\n**Step 1: Write the failing test**\n\nCreate `test/42_videodecoder_queue.js`:\n```javascript\n'use strict';\n\nconst assert = require('assert');\nconst { VideoDecoder, VideoEncoder, VideoFrame, EncodedVideoChunk } = require('../lib');\n\nasync function testVideoDecoderQueue() {\n    console.log('[TEST] VideoDecoder control queue + ondequeue');\n\n    // First encode to get chunks\n    const chunks = [];\n    const encoder = new VideoEncoder({\n        output: (chunk) => chunks.push(chunk),\n        error: (e) => console.error(`[ENCODER ERR] ${e.message}`)\n    });\n\n    encoder.configure({\n        codec: 'avc1.42001E',\n        width: 64,\n        height: 64,\n        bitrate: 100000\n    });\n\n    const frameData = Buffer.alloc(64 * 64 * 4);\n    for (let i = 0; i < 3; i++) {\n        const frame = new VideoFrame(frameData, {\n            codedWidth: 64,\n            codedHeight: 64,\n            timestamp: i * 33333\n        });\n        encoder.encode(frame, { keyFrame: i === 0 });\n        frame.close();\n    }\n    await encoder.flush();\n    encoder.close();\n\n    assert.ok(chunks.length > 0, 'Should have encoded chunks');\n\n    // Now decode\n    let dequeueCount = 0;\n    let maxQueueSize = 0;\n    const frames = [];\n\n    const decoder = new VideoDecoder({\n        output: (frame) => {\n            frames.push(frame);\n            frame.close();\n        },\n        error: (e) => console.error(`[DECODER ERR] ${e.message}`)\n    });\n\n    decoder.ondequeue = () => {\n        dequeueCount++;\n    };\n\n    decoder.configure({\n        codec: 'avc1.42001E',\n        codedWidth: 64,\n        codedHeight: 64\n    });\n\n    for (const chunk of chunks) {\n        decoder.decode(chunk);\n        if (decoder.decodeQueueSize > maxQueueSize) {\n            maxQueueSize = decoder.decodeQueueSize;\n        }\n    }\n\n    await decoder.flush();\n    decoder.close();\n\n    console.log(`Results: dequeueCount=${dequeueCount}, maxQueue=${maxQueueSize}, frames=${frames.length}`);\n\n    assert.ok(dequeueCount >= 1, `ondequeue should fire, got ${dequeueCount}`);\n\n    console.log('[PASS] VideoDecoder control queue + ondequeue works');\n}\n\ntestVideoDecoderQueue().catch(e => {\n    console.error('[FAIL]', e.message);\n    process.exit(1);\n});\n```\n\n**Step 2: Run test**\n\n```bash\nnode test/42_videodecoder_queue.js\n```\n\nExpected: FAIL\n\n**Step 3: Update VideoDecoder in lib/index.ts**\n\n```typescript\nexport class VideoDecoder {\n    private _native: any;\n    private _ondequeue: (() => void) | null = null;\n    private _controlQueue: ControlMessageQueue;\n    private _decodeQueueSize: number = 0;\n    private _needsKeyFrame: boolean = true;\n    private _errorCallback: (error: Error) => void;\n\n    constructor(init: VideoDecoderInit) {\n        this._controlQueue = new ControlMessageQueue();\n        this._errorCallback = init.error;\n        this._controlQueue.setErrorHandler(init.error);\n\n        this._native = new native.VideoDecoder({\n            output: (nativeFrame: any) => {\n                this._decodeQueueSize = Math.max(0, this._decodeQueueSize - 1);\n\n                const wrapper = Object.create(VideoFrame.prototype);\n                wrapper._native = nativeFrame;\n                wrapper._closed = false;\n                init.output(wrapper);\n\n                this._triggerDequeue();\n            },\n            error: init.error\n        });\n    }\n\n    get state(): CodecState {\n        return this._native.state;\n    }\n\n    get decodeQueueSize(): number {\n        return this._decodeQueueSize;\n    }\n\n    get ondequeue(): (() => void) | null {\n        return this._ondequeue;\n    }\n\n    set ondequeue(handler: (() => void) | null) {\n        this._ondequeue = handler;\n    }\n\n    private _triggerDequeue(): void {\n        if (this._ondequeue) {\n            queueMicrotask(() => {\n                if (this._ondequeue) {\n                    this._ondequeue();\n                }\n            });\n        }\n    }\n\n    configure(config: VideoDecoderConfig): void {\n        this._needsKeyFrame = true;\n        this._controlQueue.enqueue(() => {\n            this._native.configure(config);\n        });\n    }\n\n    decode(chunk: EncodedVideoChunk | any): void {\n        const chunkType = chunk instanceof EncodedVideoChunk ? chunk.type : chunk.type;\n\n        // W3C spec: first chunk after configure/reset must be key frame\n        if (this._needsKeyFrame && chunkType !== 'key') {\n            const error = new DOMException(\n                'First chunk after configure/reset must be a key frame',\n                'DataError'\n            );\n            this._errorCallback(error);\n            return;\n        }\n        this._needsKeyFrame = false;\n        this._decodeQueueSize++;\n\n        this._controlQueue.enqueue(() => {\n            if (chunk instanceof EncodedVideoChunk) {\n                const nativeChunk = new native.EncodedVideoChunk({\n                    type: chunk.type,\n                    timestamp: chunk.timestamp,\n                    duration: chunk.duration,\n                    data: chunk.data\n                });\n                this._native.decode(nativeChunk);\n            } else {\n                this._native.decode(chunk);\n            }\n        });\n    }\n\n    async flush(): Promise<void> {\n        await this._controlQueue.flush();\n        return this._native.flush();\n    }\n\n    reset(): void {\n        this._controlQueue.clear();\n        this._decodeQueueSize = 0;\n        this._needsKeyFrame = true;\n        this._native.reset();\n    }\n\n    close(): void {\n        this._controlQueue.clear();\n        this._native.close();\n    }\n\n    static async isConfigSupported(config: VideoDecoderConfig): Promise<{\n        supported: boolean;\n        config: VideoDecoderConfig;\n    }> {\n        return native.VideoDecoder.isConfigSupported(config);\n    }\n}\n```\n\n**Step 4: Build and run test**\n\n```bash\nnpm run build:ts && node test/42_videodecoder_queue.js\n```\n\nExpected: PASS\n\n**Step 5: Commit**\n\n```bash\ngit add lib/index.ts test/42_videodecoder_queue.js\ngit commit -m \"feat(videodecoder): integrate control queue, ondequeue, key frame check\"\n```\n\n---","role":null},"6":{"id":"6","description":"Integrate Control Queue into AudioEncoder with ondequeue","status":"pending","dependencies":["4","5"],"started_at":null,"completed_at":null,"claimed_by":null,"timeout_seconds":600,"instructions":"**Files:**\n- Modify: `lib/index.ts` (AudioEncoder class)\n- Test: `test/43_audioencoder_queue.js`\n\n**Step 1: Write the failing test**\n\nCreate `test/43_audioencoder_queue.js`:\n```javascript\n'use strict';\n\nconst assert = require('assert');\nconst { AudioEncoder, AudioData } = require('../lib');\n\nasync function testAudioEncoderQueue() {\n    console.log('[TEST] AudioEncoder control queue + ondequeue');\n\n    let dequeueCount = 0;\n    const chunks = [];\n\n    const encoder = new AudioEncoder({\n        output: (chunk, metadata) => {\n            chunks.push(chunk);\n        },\n        error: (e) => console.error(`[ERR] ${e.message}`)\n    });\n\n    encoder.ondequeue = () => {\n        dequeueCount++;\n    };\n\n    encoder.configure({\n        codec: 'mp4a.40.2',\n        sampleRate: 48000,\n        numberOfChannels: 2,\n        bitrate: 128000\n    });\n\n    // Create audio data\n    const samplesPerChannel = 1024;\n    const audioBuffer = new Float32Array(samplesPerChannel * 2);\n\n    for (let i = 0; i < 3; i++) {\n        const audioData = new AudioData({\n            format: 'f32-planar',\n            sampleRate: 48000,\n            numberOfFrames: samplesPerChannel,\n            numberOfChannels: 2,\n            timestamp: i * 21333,\n            data: audioBuffer.buffer\n        });\n        encoder.encode(audioData);\n        audioData.close();\n    }\n\n    await encoder.flush();\n    encoder.close();\n\n    console.log(`Results: dequeueCount=${dequeueCount}, chunks=${chunks.length}`);\n\n    // May skip if AAC codec unavailable\n    if (chunks.length === 0) {\n        console.log('[SKIP] No chunks produced (AAC codec may not be available)');\n        return;\n    }\n\n    assert.ok(dequeueCount >= 1, `ondequeue should fire, got ${dequeueCount}`);\n    console.log('[PASS] AudioEncoder control queue + ondequeue works');\n}\n\ntestAudioEncoderQueue().catch(e => {\n    console.error('[FAIL]', e.message);\n    process.exit(1);\n});\n```\n\n**Step 2: Run test**\n\n```bash\nnode test/43_audioencoder_queue.js\n```\n\n**Step 3: Update AudioEncoder in lib/index.ts**\n\nApply same control queue pattern as VideoEncoder.\n\n**Step 4: Build and run test**\n\n```bash\nnpm run build:ts && node test/43_audioencoder_queue.js\n```\n\n**Step 5: Commit**\n\n```bash\ngit add lib/index.ts test/43_audioencoder_queue.js\ngit commit -m \"feat(audioencoder): integrate control queue and ondequeue event\"\n```\n\n---","role":null},"7":{"id":"7","description":"Integrate Control Queue into AudioDecoder with ondequeue","status":"pending","dependencies":["4","5"],"started_at":null,"completed_at":null,"claimed_by":null,"timeout_seconds":600,"instructions":"**Files:**\n- Modify: `lib/index.ts` (AudioDecoder class)\n- Test: `test/44_audiodecoder_queue.js`\n\n**Step 1: Write the failing test**\n\nCreate `test/44_audiodecoder_queue.js`:\n```javascript\n'use strict';\n\nconst assert = require('assert');\nconst { AudioDecoder, AudioEncoder, AudioData } = require('../lib');\n\nasync function testAudioDecoderQueue() {\n    console.log('[TEST] AudioDecoder control queue + ondequeue');\n\n    // First encode\n    const chunks = [];\n    const encoder = new AudioEncoder({\n        output: (chunk) => chunks.push(chunk),\n        error: (e) => console.error(`[ENCODER ERR] ${e.message}`)\n    });\n\n    encoder.configure({\n        codec: 'mp4a.40.2',\n        sampleRate: 48000,\n        numberOfChannels: 2,\n        bitrate: 128000\n    });\n\n    const samplesPerChannel = 1024;\n    const audioBuffer = new Float32Array(samplesPerChannel * 2);\n    const audioData = new AudioData({\n        format: 'f32-planar',\n        sampleRate: 48000,\n        numberOfFrames: samplesPerChannel,\n        numberOfChannels: 2,\n        timestamp: 0,\n        data: audioBuffer.buffer\n    });\n    encoder.encode(audioData);\n    audioData.close();\n    await encoder.flush();\n    encoder.close();\n\n    if (chunks.length === 0) {\n        console.log('[SKIP] No encoded chunks (AAC codec may not be available)');\n        return;\n    }\n\n    // Now decode\n    let dequeueCount = 0;\n    const decoder = new AudioDecoder({\n        output: (data) => data.close(),\n        error: (e) => console.error(`[DECODER ERR] ${e.message}`)\n    });\n\n    decoder.ondequeue = () => {\n        dequeueCount++;\n    };\n\n    decoder.configure({\n        codec: 'mp4a.40.2',\n        sampleRate: 48000,\n        numberOfChannels: 2\n    });\n\n    for (const chunk of chunks) {\n        decoder.decode(chunk);\n    }\n\n    await decoder.flush();\n    decoder.close();\n\n    console.log(`Results: dequeueCount=${dequeueCount}`);\n    assert.ok(dequeueCount >= 1, `ondequeue should fire, got ${dequeueCount}`);\n    console.log('[PASS] AudioDecoder control queue + ondequeue works');\n}\n\ntestAudioDecoderQueue().catch(e => {\n    console.error('[FAIL]', e.message);\n    process.exit(1);\n});\n```\n\n**Step 2-5: Same pattern as AudioEncoder**\n\nApply control queue pattern to AudioDecoder, build, test, commit.\n\n```bash\ngit commit -m \"feat(audiodecoder): integrate control queue and ondequeue event\"\n```\n\n---","role":null},"8":{"id":"8","description":"Implement Key Chunk Requirement Test","status":"pending","dependencies":["6","7"],"started_at":null,"completed_at":null,"claimed_by":null,"timeout_seconds":600,"instructions":"**Files:**\n- Test: `test/45_key_chunk_requirement.js`\n\n**Context:** Task 5 already added key frame checking to VideoDecoder. This task adds explicit test coverage.\n\n**Step 1: Write the test**\n\nCreate `test/45_key_chunk_requirement.js`:\n```javascript\n'use strict';\n\nconst assert = require('assert');\nconst { VideoDecoder, EncodedVideoChunk } = require('../lib');\n\nasync function testKeyChunkRequirement() {\n    console.log('[TEST] Decoders require key chunk after configure/reset');\n\n    let errorCaught = false;\n    const decoder = new VideoDecoder({\n        output: (frame) => frame.close(),\n        error: (e) => {\n            errorCaught = true;\n            console.log(`[EXPECTED ERROR] ${e.message}`);\n        }\n    });\n\n    decoder.configure({\n        codec: 'avc1.42001E',\n        codedWidth: 64,\n        codedHeight: 64\n    });\n\n    // Create a delta chunk (not a key frame)\n    const deltaChunk = new EncodedVideoChunk({\n        type: 'delta',\n        timestamp: 0,\n        data: Buffer.from([0x00, 0x00, 0x00, 0x01, 0x41])\n    });\n\n    // Should trigger error callback\n    decoder.decode(deltaChunk);\n\n    // Give microtask queue time to process\n    await new Promise(r => setTimeout(r, 50));\n\n    decoder.close();\n\n    assert.ok(errorCaught, 'Decoder should reject delta chunk as first chunk');\n    console.log('[PASS] Key chunk requirement enforced');\n}\n\nasync function testKeyChunkAfterReset() {\n    console.log('[TEST] Key chunk required after reset');\n\n    // First do valid encoding to get real chunks\n    const { VideoEncoder, VideoFrame } = require('../lib');\n    const chunks = [];\n\n    const encoder = new VideoEncoder({\n        output: (chunk) => chunks.push(chunk),\n        error: (e) => console.error(`[ERR] ${e.message}`)\n    });\n\n    encoder.configure({\n        codec: 'avc1.42001E',\n        width: 64,\n        height: 64,\n        bitrate: 100000\n    });\n\n    const frameData = Buffer.alloc(64 * 64 * 4);\n    for (let i = 0; i < 3; i++) {\n        const frame = new VideoFrame(frameData, {\n            codedWidth: 64,\n            codedHeight: 64,\n            timestamp: i * 33333\n        });\n        encoder.encode(frame, { keyFrame: i === 0 });\n        frame.close();\n    }\n    await encoder.flush();\n    encoder.close();\n\n    if (chunks.length < 2) {\n        console.log('[SKIP] Not enough chunks for reset test');\n        return;\n    }\n\n    let errorAfterReset = false;\n    const decoder = new VideoDecoder({\n        output: (frame) => frame.close(),\n        error: (e) => {\n            errorAfterReset = true;\n            console.log(`[EXPECTED ERROR] ${e.message}`);\n        }\n    });\n\n    decoder.configure({\n        codec: 'avc1.42001E',\n        codedWidth: 64,\n        codedHeight: 64\n    });\n\n    // Decode key chunk first (should work)\n    decoder.decode(chunks[0]);\n    await decoder.flush();\n\n    // Reset\n    decoder.reset();\n\n    // Reconfigure\n    decoder.configure({\n        codec: 'avc1.42001E',\n        codedWidth: 64,\n        codedHeight: 64\n    });\n\n    // Try to decode delta chunk after reset (should fail)\n    const deltaChunk = chunks.find(c => c.type === 'delta');\n    if (deltaChunk) {\n        decoder.decode(deltaChunk);\n        await new Promise(r => setTimeout(r, 50));\n        assert.ok(errorAfterReset, 'Should reject delta after reset');\n    }\n\n    decoder.close();\n    console.log('[PASS] Key chunk required after reset');\n}\n\n(async () => {\n    await testKeyChunkRequirement();\n    await testKeyChunkAfterReset();\n    console.log('[PASS] All key chunk tests passed');\n})().catch(e => {\n    console.error('[FAIL]', e.message);\n    process.exit(1);\n});\n```\n\n**Step 2: Run test**\n\n```bash\nnode test/45_key_chunk_requirement.js\n```\n\nExpected: PASS (already implemented in Task 5)\n\n**Step 3: Commit**\n\n```bash\ngit add test/45_key_chunk_requirement.js\ngit commit -m \"test(decoder): add key chunk requirement tests\"\n```\n\n---","role":null},"9":{"id":"9","description":"Implement VideoFrame rotation, flip, and metadata()","status":"pending","dependencies":["8"],"started_at":null,"completed_at":null,"claimed_by":null,"timeout_seconds":600,"instructions":"**Files:**\n- Modify: `lib/index.ts` (VideoFrame class)\n- Modify: `src/video_frame.h`\n- Modify: `src/video_frame.cc`\n- Test: `test/46_videoframe_enhanced.js`\n\n**Step 1: Write the failing test**\n\nCreate `test/46_videoframe_enhanced.js`:\n```javascript\n'use strict';\n\nconst assert = require('assert');\nconst { VideoFrame } = require('../lib');\n\nconsole.log('[TEST] VideoFrame rotation, flip, metadata');\n\n// Test rotation and flip\nconst frameData = Buffer.alloc(640 * 480 * 4);\nconst frame = new VideoFrame(frameData, {\n    codedWidth: 640,\n    codedHeight: 480,\n    timestamp: 12345,\n    rotation: 90,\n    flip: true\n});\n\nassert.strictEqual(frame.rotation, 90, 'rotation should be 90');\nassert.strictEqual(frame.flip, true, 'flip should be true');\n\n// Test metadata\nconst metadata = frame.metadata();\nassert.ok(typeof metadata === 'object', 'metadata() should return object');\nassert.ok(metadata !== null, 'metadata should not be null');\n\nframe.close();\n\n// Test defaults\nconst frame2 = new VideoFrame(frameData, {\n    codedWidth: 640,\n    codedHeight: 480,\n    timestamp: 0\n});\n\nassert.strictEqual(frame2.rotation, 0, 'default rotation should be 0');\nassert.strictEqual(frame2.flip, false, 'default flip should be false');\n\nframe2.close();\n\n// Test closed frame throws on metadata()\nlet threw = false;\ntry {\n    frame.metadata();\n} catch (e) {\n    threw = true;\n}\nassert.ok(threw, 'metadata() should throw on closed frame');\n\nconsole.log('[PASS] VideoFrame rotation, flip, metadata works');\n```\n\n**Step 2: Run test**\n\n```bash\nnode test/46_videoframe_enhanced.js\n```\n\nExpected: FAIL\n\n**Step 3: Update src/video_frame.h**\n\nAdd fields:\n```cpp\n  int rotation_;\n  bool flip_;\n```\n\n**Step 4: Update src/video_frame.cc**\n\nIn constructor:\n```cpp\nrotation_ = 0;\nflip_ = false;\nif (init.Has(\"rotation\")) {\n    rotation_ = init.Get(\"rotation\").As<Napi::Number>().Int32Value();\n}\nif (init.Has(\"flip\")) {\n    flip_ = init.Get(\"flip\").As<Napi::Boolean>().Value();\n}\n```\n\nAdd getters:\n```cpp\nNapi::Value VideoFrame::GetRotation(const Napi::CallbackInfo& info) {\n    return Napi::Number::New(info.Env(), rotation_);\n}\n\nNapi::Value VideoFrame::GetFlip(const Napi::CallbackInfo& info) {\n    return Napi::Boolean::New(info.Env(), flip_);\n}\n```\n\nRegister in Init.\n\n**Step 5: Update lib/index.ts VideoFrame**\n\n```typescript\nget rotation(): number {\n    return this._native.rotation ?? 0;\n}\n\nget flip(): boolean {\n    return this._native.flip ?? false;\n}\n\nmetadata(): VideoFrameMetadata {\n    if (this._closed) {\n        throw new DOMException('VideoFrame is closed', 'InvalidStateError');\n    }\n    return {};\n}\n```\n\n**Step 6: Build and run test**\n\n```bash\nnpm run build && node test/46_videoframe_enhanced.js\n```\n\nExpected: PASS\n\n**Step 7: Commit**\n\n```bash\ngit add lib/index.ts src/video_frame.h src/video_frame.cc test/46_videoframe_enhanced.js\ngit commit -m \"feat(videoframe): implement rotation, flip, and metadata() per W3C spec\"\n```\n\n---","role":null},"10":{"id":"10","description":"Implement Config Validation and Hardware Acceleration Hints","status":"pending","dependencies":["9"],"started_at":null,"completed_at":null,"claimed_by":null,"timeout_seconds":600,"instructions":"**Files:**\n- Modify: `lib/index.ts` (configure methods)\n- Test: `test/47_config_validation.js`\n\n**Step 1: Write the failing test**\n\nCreate `test/47_config_validation.js`:\n```javascript\n'use strict';\n\nconst assert = require('assert');\nconst { VideoEncoder, VideoDecoder } = require('../lib');\n\nconsole.log('[TEST] Config validation and hardware acceleration');\n\n// Test displayAspect pairing\nconst encoder = new VideoEncoder({\n    output: () => {},\n    error: () => {}\n});\n\nlet threw = false;\ntry {\n    encoder.configure({\n        codec: 'avc1.42001E',\n        width: 640,\n        height: 480,\n        displayAspectWidth: 16\n        // Missing displayAspectHeight\n    });\n} catch (e) {\n    threw = true;\n    console.log(`[EXPECTED] ${e.message}`);\n}\nassert.ok(threw, 'Should throw when displayAspectWidth without Height');\n\n// Valid config with both\nencoder.configure({\n    codec: 'avc1.42001E',\n    width: 640,\n    height: 480,\n    displayAspectWidth: 16,\n    displayAspectHeight: 9\n});\n\n// Test hardware acceleration hint\nencoder.configure({\n    codec: 'avc1.42001E',\n    width: 640,\n    height: 480,\n    hardwareAcceleration: 'prefer-software'\n});\n\nencoder.close();\n\n// Test decoder config\nconst decoder = new VideoDecoder({\n    output: () => {},\n    error: () => {}\n});\n\ndecoder.configure({\n    codec: 'avc1.42001E',\n    hardwareAcceleration: 'prefer-hardware',\n    optimizeForLatency: true\n});\n\ndecoder.close();\n\nconsole.log('[PASS] Config validation and hardware acceleration hints work');\n```\n\n**Step 2: Run test**\n\n```bash\nnode test/47_config_validation.js\n```\n\n**Step 3: Ensure validation in configure methods**\n\nAlready added displayAspect validation in Task 4. Verify hardware acceleration is passed through.\n\n**Step 4: Build and run test**\n\n```bash\nnpm run build:ts && node test/47_config_validation.js\n```\n\n**Step 5: Commit**\n\n```bash\ngit add test/47_config_validation.js\ngit commit -m \"test(config): add validation and hardware acceleration tests\"\n```\n\n---","role":null},"11":{"id":"11","description":"Implement Resource Reclamation System","status":"pending","dependencies":["10"],"started_at":null,"completed_at":null,"claimed_by":null,"timeout_seconds":600,"instructions":"**Files:**\n- Create: `lib/resource-manager.ts`\n- Modify: `lib/index.ts` (register codecs with manager)\n- Test: `test/48_resource_reclamation.js`\n\n**Context:** Per W3C spec, inactive codecs (no progress in 10 seconds) may be reclaimed. This implements a resource manager that tracks codec activity.\n\n**Step 1: Write the failing test**\n\nCreate `test/48_resource_reclamation.js`:\n```javascript\n'use strict';\n\nconst assert = require('assert');\nconst { VideoEncoder, VideoFrame, ResourceManager } = require('../lib');\n\nasync function testResourceReclamation() {\n    console.log('[TEST] Resource reclamation system');\n\n    const manager = ResourceManager.getInstance();\n    const initialCount = manager.getActiveCodecCount();\n\n    const encoder = new VideoEncoder({\n        output: () => {},\n        error: (e) => console.error(`[ERR] ${e.message}`)\n    });\n\n    encoder.configure({\n        codec: 'avc1.42001E',\n        width: 64,\n        height: 64,\n        bitrate: 100000\n    });\n\n    // Should be registered\n    assert.ok(manager.getActiveCodecCount() > initialCount,\n        'Codec should be registered with manager');\n\n    // Record activity\n    const frameData = Buffer.alloc(64 * 64 * 4);\n    const frame = new VideoFrame(frameData, {\n        codedWidth: 64,\n        codedHeight: 64,\n        timestamp: 0\n    });\n    encoder.encode(frame, { keyFrame: true });\n    frame.close();\n\n    await encoder.flush();\n    encoder.close();\n\n    // Should be unregistered after close\n    assert.strictEqual(manager.getActiveCodecCount(), initialCount,\n        'Codec should be unregistered after close');\n\n    console.log('[PASS] Resource reclamation system works');\n}\n\nasync function testInactivityDetection() {\n    console.log('[TEST] Inactivity detection');\n\n    const manager = ResourceManager.getInstance();\n\n    // Configure short timeout for testing (normally 10s)\n    manager.setInactivityTimeout(100); // 100ms for test\n\n    const encoder = new VideoEncoder({\n        output: () => {},\n        error: (e) => console.log(`[EXPECTED] ${e.message}`)\n    });\n\n    encoder.configure({\n        codec: 'avc1.42001E',\n        width: 64,\n        height: 64,\n        bitrate: 100000\n    });\n\n    // Wait for inactivity timeout\n    await new Promise(r => setTimeout(r, 200));\n\n    // Check if marked as reclaimable\n    const reclaimable = manager.getReclaimableCodecs();\n    console.log(`Reclaimable codecs: ${reclaimable.length}`);\n\n    encoder.close();\n\n    // Reset timeout\n    manager.setInactivityTimeout(10000);\n\n    console.log('[PASS] Inactivity detection works');\n}\n\n(async () => {\n    await testResourceReclamation();\n    await testInactivityDetection();\n    console.log('[PASS] All resource reclamation tests passed');\n})().catch(e => {\n    console.error('[FAIL]', e.message);\n    process.exit(1);\n});\n```\n\n**Step 2: Run test**\n\n```bash\nnode test/48_resource_reclamation.js\n```\n\nExpected: FAIL - ResourceManager doesn't exist\n\n**Step 3: Create lib/resource-manager.ts**\n\n```typescript\n/**\n * Resource Manager per W3C WebCodecs spec.\n *\n * Tracks codec instances and their activity for resource reclamation.\n * Inactive codecs (no progress in 10 seconds) may be reclaimed.\n */\n\ninterface CodecEntry {\n    codec: any;\n    lastActivity: number;\n    isBackground: boolean;\n}\n\nexport class ResourceManager {\n    private static instance: ResourceManager | null = null;\n    private codecs: Map<symbol, CodecEntry> = new Map();\n    private inactivityTimeout: number = 10000; // 10 seconds per spec\n    private checkInterval: NodeJS.Timeout | null = null;\n\n    private constructor() {\n        this.startMonitoring();\n    }\n\n    static getInstance(): ResourceManager {\n        if (!ResourceManager.instance) {\n            ResourceManager.instance = new ResourceManager();\n        }\n        return ResourceManager.instance;\n    }\n\n    /**\n     * Register a codec for tracking.\n     */\n    register(codec: any): symbol {\n        const id = Symbol('codec');\n        this.codecs.set(id, {\n            codec,\n            lastActivity: Date.now(),\n            isBackground: false\n        });\n        return id;\n    }\n\n    /**\n     * Unregister a codec (on close).\n     */\n    unregister(id: symbol): void {\n        this.codecs.delete(id);\n    }\n\n    /**\n     * Record activity on a codec.\n     */\n    recordActivity(id: symbol): void {\n        const entry = this.codecs.get(id);\n        if (entry) {\n            entry.lastActivity = Date.now();\n        }\n    }\n\n    /**\n     * Mark codec as background (eligible for reclamation).\n     */\n    setBackground(id: symbol, isBackground: boolean): void {\n        const entry = this.codecs.get(id);\n        if (entry) {\n            entry.isBackground = isBackground;\n        }\n    }\n\n    /**\n     * Get count of active codecs.\n     */\n    getActiveCodecCount(): number {\n        return this.codecs.size;\n    }\n\n    /**\n     * Get codecs eligible for reclamation.\n     * Per spec: inactive (no progress in 10s) OR background codecs.\n     */\n    getReclaimableCodecs(): any[] {\n        const now = Date.now();\n        const reclaimable: any[] = [];\n\n        for (const [id, entry] of this.codecs) {\n            const inactive = (now - entry.lastActivity) > this.inactivityTimeout;\n\n            // Only reclaim if inactive OR (background AND inactive)\n            // Spec says: \"You must not reclaim a codec that is both active and in the foreground\"\n            if (inactive || entry.isBackground) {\n                reclaimable.push(entry.codec);\n            }\n        }\n\n        return reclaimable;\n    }\n\n    /**\n     * Reclaim resources from inactive codecs.\n     */\n    reclaimInactive(): number {\n        const reclaimable = this.getReclaimableCodecs();\n        let reclaimed = 0;\n\n        for (const codec of reclaimable) {\n            try {\n                if (codec.state !== 'closed' && typeof codec.close === 'function') {\n                    codec.close();\n                    reclaimed++;\n                }\n            } catch (e) {\n                // Ignore errors during reclamation\n            }\n        }\n\n        return reclaimed;\n    }\n\n    /**\n     * Set inactivity timeout (for testing).\n     */\n    setInactivityTimeout(ms: number): void {\n        this.inactivityTimeout = ms;\n    }\n\n    private startMonitoring(): void {\n        // Check every 5 seconds\n        this.checkInterval = setInterval(() => {\n            // Just track, don't auto-reclaim\n            // Actual reclamation would be triggered by memory pressure\n        }, 5000);\n\n        // Don't keep process alive\n        if (this.checkInterval.unref) {\n            this.checkInterval.unref();\n        }\n    }\n\n    /**\n     * Stop monitoring (for cleanup).\n     */\n    stopMonitoring(): void {\n        if (this.checkInterval) {\n            clearInterval(this.checkInterval);\n            this.checkInterval = null;\n        }\n    }\n}\n```\n\n**Step 4: Integrate with codecs in lib/index.ts**\n\nAdd to VideoEncoder constructor:\n```typescript\nprivate _resourceId: symbol;\n\nconstructor(init: VideoEncoderInit) {\n    // ... existing code ...\n    this._resourceId = ResourceManager.getInstance().register(this);\n}\n\nencode(frame: VideoFrame, options?: { keyFrame?: boolean }): void {\n    ResourceManager.getInstance().recordActivity(this._resourceId);\n    // ... existing code ...\n}\n\nclose(): void {\n    ResourceManager.getInstance().unregister(this._resourceId);\n    // ... existing code ...\n}\n```\n\nExport ResourceManager:\n```typescript\nexport { ResourceManager } from './resource-manager';\n```\n\n**Step 5: Build and run test**\n\n```bash\nnpm run build:ts && node test/48_resource_reclamation.js\n```\n\nExpected: PASS\n\n**Step 6: Commit**\n\n```bash\ngit add lib/resource-manager.ts lib/index.ts test/48_resource_reclamation.js\ngit commit -m \"feat(core): implement resource reclamation system per W3C spec\"\n```\n\n---","role":null},"12":{"id":"12","description":"Create Native ImageDecoder Foundation","status":"pending","dependencies":["11"],"started_at":null,"completed_at":null,"claimed_by":null,"timeout_seconds":600,"instructions":"**Files:**\n- Create: `src/image_decoder.h`\n- Create: `src/image_decoder.cc`\n- Modify: `src/addon.cc`\n- Test: `test/49_imagedecoder_basic.js`\n\n**Step 1: Write the failing test**\n\nCreate `test/49_imagedecoder_basic.js`:\n```javascript\n'use strict';\n\nconst assert = require('assert');\nconst { ImageDecoder } = require('../lib');\n\nconsole.log('[TEST] ImageDecoder basic instantiation');\n\n// Minimal 1x1 red PNG\nconst minimalPng = Buffer.from([\n    0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A,\n    0x00, 0x00, 0x00, 0x0D, 0x49, 0x48, 0x44, 0x52,\n    0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,\n    0x08, 0x02, 0x00, 0x00, 0x00, 0x90, 0x77, 0x53,\n    0xDE, 0x00, 0x00, 0x00, 0x0C, 0x49, 0x44, 0x41,\n    0x54, 0x08, 0xD7, 0x63, 0xF8, 0xCF, 0xC0, 0x00,\n    0x00, 0x00, 0x03, 0x00, 0x01, 0x00, 0x18, 0xDD,\n    0x8D, 0xB4, 0x00, 0x00, 0x00, 0x00, 0x49, 0x45,\n    0x4E, 0x44, 0xAE, 0x42, 0x60, 0x82\n]);\n\nconst decoder = new ImageDecoder({\n    type: 'image/png',\n    data: minimalPng\n});\n\nassert.strictEqual(decoder.type, 'image/png');\nassert.strictEqual(typeof decoder.complete, 'boolean');\nassert.ok(decoder.tracks !== undefined);\nassert.strictEqual(decoder.tracks.length, 1);\n\ndecoder.close();\n\nconsole.log('[PASS] ImageDecoder basic instantiation works');\n```\n\n**Step 2-6: Create native ImageDecoder**\n\nFollow pattern from existing codec classes. See original plan Task 11 for full implementation details.\n\n**Step 7: Commit**\n\n```bash\ngit commit -m \"feat(imagedecoder): create native ImageDecoder foundation\"\n```\n\n---","role":null},"13":{"id":"13","description":"Create TypeScript ImageDecoder Wrapper","status":"pending","dependencies":["11"],"started_at":null,"completed_at":null,"claimed_by":null,"timeout_seconds":600,"instructions":"**Files:**\n- Modify: `lib/index.ts`\n- Test: `test/49_imagedecoder_basic.js` (reuse)\n\n**Step 1-4: Add TypeScript wrapper**\n\nSee original plan Task 12 for implementation.\n\n**Step 5: Commit**\n\n```bash\ngit commit -m \"feat(imagedecoder): add TypeScript ImageDecoder wrapper\"\n```\n\n---","role":null},"14":{"id":"14","description":"Implement ImageDecoder.decode() with FFmpeg","status":"pending","dependencies":["11"],"started_at":null,"completed_at":null,"claimed_by":null,"timeout_seconds":600,"instructions":"**Files:**\n- Modify: `src/image_decoder.cc`\n- Test: `test/50_imagedecoder_decode.js`\n\n**Step 1: Write the failing test**\n\nCreate `test/50_imagedecoder_decode.js`:\n```javascript\n'use strict';\n\nconst assert = require('assert');\nconst { ImageDecoder } = require('../lib');\n\nasync function testImageDecoderDecode() {\n    console.log('[TEST] ImageDecoder.decode() produces VideoFrame');\n\n    // Minimal 1x1 PNG\n    const minimalPng = Buffer.from([\n        0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A,\n        0x00, 0x00, 0x00, 0x0D, 0x49, 0x48, 0x44, 0x52,\n        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,\n        0x08, 0x02, 0x00, 0x00, 0x00, 0x90, 0x77, 0x53,\n        0xDE, 0x00, 0x00, 0x00, 0x0C, 0x49, 0x44, 0x41,\n        0x54, 0x08, 0xD7, 0x63, 0xF8, 0xCF, 0xC0, 0x00,\n        0x00, 0x00, 0x03, 0x00, 0x01, 0x00, 0x18, 0xDD,\n        0x8D, 0xB4, 0x00, 0x00, 0x00, 0x00, 0x49, 0x45,\n        0x4E, 0x44, 0xAE, 0x42, 0x60, 0x82\n    ]);\n\n    const decoder = new ImageDecoder({\n        type: 'image/png',\n        data: minimalPng\n    });\n\n    const result = await decoder.decode();\n\n    assert.ok(result.image !== undefined, 'decode() should return image');\n    assert.strictEqual(typeof result.complete, 'boolean');\n    assert.strictEqual(result.image.codedWidth, 1);\n    assert.strictEqual(result.image.codedHeight, 1);\n\n    result.image.close();\n    decoder.close();\n\n    console.log('[PASS] ImageDecoder.decode() works');\n}\n\n// Test isTypeSupported\nasync function testIsTypeSupported() {\n    console.log('[TEST] ImageDecoder.isTypeSupported()');\n\n    assert.strictEqual(await ImageDecoder.isTypeSupported('image/png'), true);\n    assert.strictEqual(await ImageDecoder.isTypeSupported('image/jpeg'), true);\n    assert.strictEqual(await ImageDecoder.isTypeSupported('image/fake'), false);\n\n    console.log('[PASS] ImageDecoder.isTypeSupported() works');\n}\n\n(async () => {\n    await testImageDecoderDecode();\n    await testIsTypeSupported();\n    console.log('[PASS] All ImageDecoder tests passed');\n})().catch(e => {\n    console.error('[FAIL]', e.message);\n    process.exit(1);\n});\n```\n\n**Step 2-6: Implement decode()**\n\nSee original plan Task 13 for FFmpeg implementation.\n\n**Step 7: Commit**\n\n```bash\ngit commit -m \"feat(imagedecoder): implement decode() with FFmpeg\"\n```\n\n---","role":null},"15":{"id":"15","description":"Code Review","status":"pending","dependencies":["12","13","14"],"started_at":null,"completed_at":null,"claimed_by":null,"timeout_seconds":600,"instructions":"**Files:**\n- All modified files from Tasks 1-14\n\n**Step 1: Review all changes**\n\n```bash\ngit diff HEAD~14..HEAD --stat\ngit log --oneline HEAD~14..HEAD\n```\n\n**Step 2: Run full test suite**\n\n```bash\nnpm test\n```\n\n**Step 3: Run linters**\n\n```bash\ncpplint --recursive src/\nnpm run build:ts\n```\n\n**Step 4: Verify W3C compliance checklist**\n\n- [ ] Control message queue implemented\n- [ ] Codec saturation tracking works\n- [ ] ondequeue fires on all codecs\n- [ ] Key chunk requirement enforced\n- [ ] VideoFrame rotation/flip/metadata() work\n- [ ] Config validation for displayAspect\n- [ ] Hardware acceleration hints pass through\n- [ ] Resource reclamation system tracks codecs\n- [ ] ImageDecoder decodes PNG/JPEG\n\n**Step 5: Final commit if fixes needed**\n\n```bash\ngit add -A\ngit commit -m \"fix: address code review feedback\"\n```\n\n---\n\n## Summary\n\nThis revised plan implements full W3C WebCodecs specification compliance:\n\n| Feature | Task(s) | Status |\n|---------|---------|--------|\n| Control Message Queue | 1, 4-7 | Per-codec async queue |\n| Codec Saturation | 2 | `[[codec saturated]]` tracking |\n| ondequeue Event | 4-7 | All codecs fire events |\n| Key Chunk Requirement | 5, 8 | Decoders enforce key frame first |\n| VideoFrame Enhancements | 9 | rotation, flip, metadata() |\n| Config Validation | 10 | displayAspect pairing |\n| Hardware Acceleration | 10 | Hints pass through |\n| Resource Reclamation | 11 | 10s inactivity tracking |\n| ImageDecoder | 12-14 | Full FFmpeg implementation |\n| Type Definitions | 3 | Complete W3C types |\n\nTotal: 15 tasks across 9 parallel groups.","role":null}}}