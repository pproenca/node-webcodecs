# Spec Analysis: 2.3 (Codec Work Parallel Queue)

## Algorithms to Implement

### Parallel Queue Semantics
**Spec Section:** 2.3
**Requirements:**
1. Each codec has [[codec work queue]] - a parallel queue (runs on background thread)
2. [[codec implementation]] accessed only from work queue
3. Tasks queued back to event loop use codec task source

### Current Implementation

The implementation uses AsyncEncodeWorker (C++) which provides:

1. **Background Worker Thread** (WorkerThread method)
   - Runs encoding on dedicated thread
   - Isolated from main thread

2. **Thread-Safe Task Queue**
   - `queue_mutex_` protects `task_queue_`
   - `queue_cv_` for signaling
   - `processing_` counter tracks in-flight work

3. **TSFN for Callbacks**
   - `output_tsfn_` delivers results to main thread
   - `error_tsfn_` delivers errors to main thread
   - NonBlockingCall ensures no main thread blocking

4. **Thread Safety**
   - `codec_mutex_` protects codec access
   - `codec_valid_` atomic flag for shutdown safety
   - RAII wrappers for FFmpeg resources

## Error Conditions (spec-mandated)

| Error | Condition | Implementation |
|-------|-----------|----------------|
| Worker error | FFmpeg encode fails | error_tsfn_.NonBlockingCall |
| Resource exhaustion | Queue exceeds hard limit | QuotaExceededError |

## Existing Test Coverage

From `test/stress/thread-safety.test.ts`:
- Issue #8: Hard queue limit (QuotaExceededError)
- Issue #2: Queue race condition (flush/encode cycles)
- Issue #6: Resource cleanup on abort

From `test/stress/backpressure.test.ts`:
- Backpressure mechanisms

## Test Requirements

### Unit Tests Required
1. Encode operation doesn't block main thread
2. Decode operation doesn't block main thread
3. Callbacks run on main thread
4. Multiple concurrent operations handled

### Edge Cases to Test
1. Rapid encode() calls exceeding queue capacity
2. decode() while previous decode pending
3. flush() during active encoding

### Error Cases to Test
1. Worker thread error → error callback on main thread
2. Resource exhaustion → proper error propagation
3. Cancellation during worker execution

## Gaps in Current Test Coverage

The stress tests focus on specific issues. Need tests that specifically verify:
1. Non-blocking behavior (encode doesn't block event loop)
2. Callback thread verification (callbacks run on main thread)
3. Concurrent operation handling

## Implementation Strategy

The existing implementation correctly implements the parallel queue pattern:
1. AsyncEncodeWorker provides background thread execution
2. TSFN provides main thread callback delivery
3. Mutexes provide thread-safe queue access

Tests should verify:
1. The observable behavior matches spec requirements
2. No regressions in thread safety
3. Proper error propagation across threads

## Inputs NOT in Test Requirements (Must Still Work)

- Very large frames (high memory pressure)
- Very rapid encode calls (stress queue)
- Encode during flush operation
- Reset during active encoding
- Close with pending callbacks
