# Spec Analysis: 9.1 Memory Model

## Algorithms to Implement

### close() Method
**Spec Section:** 9.1.2
**Algorithm Steps:**
1. Clear [[resource reference]] slot
2. Release reference to media resource
3. Object becomes "closed" state

**Error Conditions (spec-mandated):**
- None - close() is always allowed

**Edge Cases (from spec):**
- close() should be idempotent (can be called multiple times safely)
- Attributes return default values after close (0, null)

### clone() Method
**Spec Section:** 9.1.2
**Algorithm Steps:**
1. Create new object
2. Set new object's [[resource reference]] to same media resource
3. Return new object (both original and clone share underlying resource)

**Error Conditions (spec-mandated):**
- InvalidStateError if called on closed object

**Edge Cases (from spec):**
- Clone of clone should work
- Closing clone should not affect original
- Closing original should not affect clone

### Transfer Semantics
**Spec Section:** 9.1.3
**Algorithm Steps:**
1. Move [[resource reference]] to destination object
2. Close source object (set closed state)

**Edge Cases (from spec):**
- Transfer effectively moves ownership
- Original becomes unusable after transfer

### Serialization Semantics
**Spec Section:** 9.1.3
**Algorithm Steps:**
1. Effectively clone() the source object
2. Both objects reference same media resource

## Inputs NOT in Test Requirements (Must Still Work)

- Multiple clones of same resource
- Cloning after some clones have been closed
- Closing in any order (first clone last, last clone first)
- Very large media resources (stress test)
- Rapid clone/close cycles

## Test Categories Based on Spec

1. **close() behavior:**
   - close() marks object as closed
   - Attributes return 0/null after close
   - close() is idempotent
   - Operations on closed object throw InvalidStateError

2. **clone() behavior:**
   - clone() returns new object
   - clone() throws InvalidStateError if source is closed
   - Clone has same data as original
   - Closing original doesn't affect clone
   - Closing clone doesn't affect original

3. **Reference counting:**
   - Clone shares underlying resource (not a copy)
   - Resource stays alive while any clone exists
   - Resource released when all clones closed

4. **Transfer semantics:**
   - Transfer closes source
   - Source throws after transfer
   - Destination works correctly

Note: Transfer is complex in Node.js (no Worker.postMessage), so we'll focus on
verifying the transfer utility detaches ArrayBuffers correctly.
