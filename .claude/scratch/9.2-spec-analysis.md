# Spec Analysis: 9.2 AudioData Interface

## Algorithms to Implement

### Constructor (9.2.2)
**Spec Section:** 9.2.2
**Algorithm Steps:**
1. Validate init is valid AudioDataInit
2. Check transfer for duplicate ArrayBuffer references
3. Check transfer for detached ArrayBuffers
4. Create AudioData with format, sampleRate, numberOfFrames, numberOfChannels, timestamp
5. Copy or reference data
6. Detach transferred ArrayBuffers
7. Return AudioData

**Error Conditions (spec-mandated):**
- TypeError: if init is not valid AudioDataInit
- DataCloneError: if transfer contains duplicate ArrayBuffer
- DataCloneError: if transfer contains detached ArrayBuffer

### Attributes (9.2.3)
**Spec Section:** 9.2.3
- format: AudioSampleFormat | null (null when detached)
- sampleRate: number
- numberOfFrames: number
- numberOfChannels: number
- timestamp: number (microseconds)
- duration: computed as (numberOfFrames / sampleRate) * 1000000

### allocationSize(options) (9.2.4)
**Spec Section:** 9.2.4
**Algorithm Steps:**
1. If detached, throw InvalidStateError
2. Compute copy element count
3. Get destFormat (default to [[format]])
4. Get bytesPerSample for destFormat
5. Return bytesPerSample * copyElementCount

**Error Conditions:**
- InvalidStateError: if closed/detached
- RangeError: if planeIndex invalid
- TypeError: if planeIndex missing

### copyTo(destination, options) (9.2.4)
**Spec Section:** 9.2.4
**Algorithm Steps:**
1. If detached, throw InvalidStateError
2. Compute copy element count
3. Get destFormat
4. Get bytesPerSample
5. If required size > destination.byteLength, throw RangeError
6. Get media resource
7. Get plane frames
8. Copy (with optional format conversion)

**Error Conditions:**
- InvalidStateError: if closed/detached
- RangeError: if destination too small
- RangeError: if planeIndex invalid
- RangeError: if frameOffset >= frameCount
- NotSupportedError: if format conversion not supported

### clone() (9.2.4)
**Spec Section:** 9.2.4
**Algorithm Steps:**
1. If detached, throw InvalidStateError
2. Run Clone AudioData algorithm

### close() (9.2.4)
**Spec Section:** 9.2.4
**Algorithm Steps:**
1. Set detached = true
2. Clear resource reference
3. Reset all values

### Compute Copy Element Count (9.2.5)
**Spec Section:** 9.2.5
**Algorithm Steps:**
1. Get destFormat
2. For interleaved: planeIndex must be 0
3. For planar: planeIndex < numberOfChannels
4. Check format conversion support
5. Get frameCount from plane
6. Validate frameOffset
7. Compute copyFrameCount
8. Validate frameCount option
9. For interleaved: multiply by numberOfChannels
10. Return element count

## Valid AudioDataInit (9.2.5)
- sampleRate > 0
- numberOfFrames > 0
- numberOfChannels > 0
- data has enough bytes

## AudioSampleFormat bytes per sample
- u8, u8-planar: 1 byte
- s16, s16-planar: 2 bytes
- s32, s32-planar, f32, f32-planar: 4 bytes

## Interleaved vs Planar
- Interleaved: u8, s16, s32, f32 (all channels in single plane)
- Planar: u8-planar, s16-planar, s32-planar, f32-planar (one plane per channel)
