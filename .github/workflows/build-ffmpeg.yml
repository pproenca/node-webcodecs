# FFmpeg Static Binary Build Workflow
# Based on GitHub Actions best practices for multi-platform native binary builds
#
# Key patterns applied:
# - Matrix strategy for parallel platform builds
# - Native runners (not QEMU emulation) for macOS arm64/x64
# - Docker buildx with GHA cache for Linux builds
# - Tar archives to preserve file permissions in artifacts
# - OIDC for npm publishing (no long-lived tokens)
# - Minimal GITHUB_TOKEN permissions per job
# - Pinned action versions for security
#
# Runner/Action versions updated: January 2026
# - macos-13 deprecated Dec 2025, using macos-15-intel for x64
# - macos-15 for ARM64 (macos-latest)
# - ubuntu-latest = Ubuntu 24.04
# - All actions on Node.js 24 (v5/v6 releases)

name: Build FFmpeg Static Binaries

on:
  push:
    tags:
      - 'v*'
      - 'deps-*'  # Also trigger on deps releases (e.g., deps-v1, deps-v2)
  workflow_dispatch:
    inputs:
      ffmpeg_version:
        description: 'FFmpeg version/branch to build'
        required: false
        default: 'master'
      skip_publish:
        description: 'Skip npm publish step'
        required: false
        type: boolean
        default: false
      deps_version:
        description: 'Create deps release with this version (e.g., v1, v2). Leave empty to skip deps release.'
        required: false
        type: string
        default: ''

# Default minimal permissions - override per job
permissions:
  contents: read

env:
  # Codec versions - update these for reproducible builds (Jan 2026)
  X264_VERSION: 'stable'
  X265_VERSION: '3.6'
  LIBVPX_VERSION: 'v1.15.2'
  LIBAOM_VERSION: 'v3.12.1'
  OPUS_VERSION: '1.5.2'
  LAME_VERSION: '3.100'
  FFMPEG_VERSION: 'n8.0'
  # SHA256 checksums for tarball downloads (hermetic build verification)
  # These MUST be updated when changing versions above
  # Sources: https://opus-codec.org/downloads/, https://sourceforge.net/projects/lame/
  # NASM uses GitHub source archive (more reliable than nasm.us)
  NASM_VERSION: '2.16.03'
  NASM_SHA256: 'e7f77b8247de72f3c2a2c57a9c72b2a0c847ec5e99ce6e68c1e225fa2e37c04c' # GitHub source archive
  OPUS_SHA256: '65c1d2f78b9f2fb20082c38cbe47c951ad5839345876e46941612ee87f9a7ce1'
  LAME_SHA256: 'ddfe36cab873794038ae2c1210557ad34857a4b6bdc515785d1da9e175b1da1e'
  # npm scope for platform packages
  NPM_SCOPE: '@pproenca/ffmpeg'
  # Bump this to invalidate all caches
  CACHE_VERSION: '11'
  # macOS deployment target - must match binding.gyp MACOSX_DEPLOYMENT_TARGET
  # This ensures ABI compatibility between FFmpeg libs and the native addon.
  # Using 11.0 (Big Sur) as minimum for widest compatibility.
  MACOS_DEPLOYMENT_TARGET: '11.0'

jobs:
  # ============================================================================
  # Linux x64 Build - Docker-based for musl static linking
  # ============================================================================
  build-linux-x64:
    name: Build Linux x64 (musl)
    runs-on: ubuntu-24.04  # Explicit version for reproducibility
    permissions:
      contents: read

    steps:
      - name: Checkout
        uses: actions/checkout@v6

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build FFmpeg in Alpine container
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ./docker/Dockerfile.linux-x64
          push: false
          load: true
          tags: ffmpeg-builder:linux-x64
          cache-from: type=gha,scope=linux-x64-v${{ env.CACHE_VERSION }}
          cache-to: type=gha,mode=max,scope=linux-x64-v${{ env.CACHE_VERSION }}

      - name: Extract binaries and dev files from container
        run: |
          mkdir -p artifacts/linux-x64/{bin,lib,include}
          docker create --name extract ffmpeg-builder:linux-x64

          # Extract binaries
          docker cp extract:/build/bin/ffmpeg artifacts/linux-x64/bin/ffmpeg
          docker cp extract:/build/bin/ffprobe artifacts/linux-x64/bin/ffprobe

          # Extract development files (needed for native addon compilation)
          docker cp extract:/build/lib/. artifacts/linux-x64/lib/
          docker cp extract:/build/include/. artifacts/linux-x64/include/

          docker rm -f extract 2>/dev/null || true

          # Verify extraction succeeded
          if [ ! -f artifacts/linux-x64/bin/ffmpeg ]; then
            echo "ERROR: ffmpeg binary not extracted from container"
            exit 1
          fi

          # Verify static linking
          echo "Verifying static binary..."
          file artifacts/linux-x64/bin/ffmpeg
          ! ldd artifacts/linux-x64/bin/ffmpeg 2>/dev/null || echo "Warning: binary may have dynamic deps"

          # Get version info
          chmod +x artifacts/linux-x64/bin/ffmpeg
          ./artifacts/linux-x64/bin/ffmpeg -version > artifacts/linux-x64/version.txt 2>&1 || {
            echo "WARNING: ffmpeg binary failed to execute - binary may be broken"
            echo "Continuing anyway as version.txt is informational"
          }

          # Verify dev files extracted
          echo "=== Library files ==="
          ls -la artifacts/linux-x64/lib/
          echo "=== Pkgconfig files ==="
          ls -la artifacts/linux-x64/lib/pkgconfig/ || echo "Warning: No pkgconfig directory"

      # Tar to preserve permissions (chmod +x is lost in artifact upload)
      - name: Package artifacts
        run: |
          cd artifacts
          tar -cvf linux-x64.tar linux-x64/

      - name: Upload artifact
        uses: actions/upload-artifact@v6
        with:
          name: ffmpeg-linux-x64
          path: artifacts/linux-x64.tar
          retention-days: 7
          compression-level: 0  # Already compressed, faster upload

  # ============================================================================
  # Linux x64 Build (glibc) - For native addon linking on Ubuntu/Debian
  # ============================================================================
  # The musl build above produces fully static binaries but its static libraries
  # cannot be linked into shared objects on glibc systems. This build produces
  # static libraries compatible with glibc for use by build-prebuilds.yml.
  # ============================================================================
  build-linux-x64-glibc:
    name: Build Linux x64 (glibc)
    runs-on: ubuntu-24.04
    permissions:
      contents: read

    steps:
      - name: Checkout
        uses: actions/checkout@v6

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build FFmpeg in Ubuntu container
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ./docker/Dockerfile.linux-x64-glibc
          push: false
          load: true
          tags: ffmpeg-builder:linux-x64-glibc
          cache-from: type=gha,scope=linux-x64-glibc-v${{ env.CACHE_VERSION }}
          cache-to: type=gha,mode=max,scope=linux-x64-glibc-v${{ env.CACHE_VERSION }}

      - name: Extract binaries and dev files from container
        run: |
          mkdir -p artifacts/linux-x64-glibc/{bin,lib,include}
          docker create --name extract-glibc ffmpeg-builder:linux-x64-glibc

          # Extract binaries
          docker cp extract-glibc:/build/bin/ffmpeg artifacts/linux-x64-glibc/bin/ffmpeg
          docker cp extract-glibc:/build/bin/ffprobe artifacts/linux-x64-glibc/bin/ffprobe

          # Extract development files (needed for native addon compilation)
          docker cp extract-glibc:/build/lib/. artifacts/linux-x64-glibc/lib/
          docker cp extract-glibc:/build/include/. artifacts/linux-x64-glibc/include/

          docker rm -f extract-glibc 2>/dev/null || true

          # Verify extraction succeeded
          if [ ! -f artifacts/linux-x64-glibc/bin/ffmpeg ]; then
            echo "ERROR: ffmpeg binary not extracted from container"
            exit 1
          fi

          # Verify glibc linking (should show libc.so.6)
          echo "Verifying glibc binary..."
          file artifacts/linux-x64-glibc/bin/ffmpeg
          ldd artifacts/linux-x64-glibc/bin/ffmpeg || echo "Note: ldd may fail if glibc versions differ"

          # Get version info
          chmod +x artifacts/linux-x64-glibc/bin/ffmpeg
          ./artifacts/linux-x64-glibc/bin/ffmpeg -version > artifacts/linux-x64-glibc/version.txt 2>&1 || {
            echo "WARNING: ffmpeg binary failed to execute - binary may be broken"
            echo "Continuing anyway as version.txt is informational"
          }

          # Verify dev files extracted
          echo "=== Library files ==="
          ls -la artifacts/linux-x64-glibc/lib/
          echo "=== Pkgconfig files ==="
          ls -la artifacts/linux-x64-glibc/lib/pkgconfig/ || echo "Warning: No pkgconfig directory"

      - name: Package artifacts
        run: |
          cd artifacts
          tar -cvf linux-x64-glibc.tar linux-x64-glibc/

      - name: Upload artifact
        uses: actions/upload-artifact@v6
        with:
          name: ffmpeg-linux-x64-glibc
          path: artifacts/linux-x64-glibc.tar
          retention-days: 7
          compression-level: 0

  # ============================================================================
  # macOS Builds - Native runners for both architectures
  # ============================================================================
  build-macos:
    name: Build macOS ${{ matrix.arch }}
    runs-on: ${{ matrix.runner }}
    permissions:
      contents: read

    strategy:
      fail-fast: false
      matrix:
        include:
          # macos-13 deprecated Dec 2025 - use macos-15-intel for x64
          # macos-15-intel available until Aug 2027 (last Intel runner)
          - runner: macos-15-intel
            arch: x64
            target: x86_64
          # macos-15 is ARM64 (same as macos-latest since Aug 2025)
          - runner: macos-15
            arch: arm64
            target: arm64

    env:
      TARGET: ${{ github.workspace }}/ffmpeg_build
      ARCH: ${{ matrix.target }}
      MACOSX_DEPLOYMENT_TARGET: ${{ env.MACOS_DEPLOYMENT_TARGET }}

    steps:
      - name: Checkout
        uses: actions/checkout@v6

      - name: Install build dependencies
        run: |
          brew install autoconf automake libtool nasm cmake pkg-config

      - name: Cache compiled libraries
        uses: actions/cache@v5
        id: cache-libs
        with:
          path: |
            ${{ github.workspace }}/ffmpeg_build
            ${{ github.workspace }}/ffmpeg_sources
          # Include ALL library versions to ensure cache invalidates when any dependency changes
          key: macos-${{ matrix.arch }}-libs-${{ env.X264_VERSION }}-${{ env.X265_VERSION }}-${{ env.LIBVPX_VERSION }}-${{ env.LIBAOM_VERSION }}-${{ env.OPUS_VERSION }}-${{ env.LAME_VERSION }}-${{ env.MACOS_DEPLOYMENT_TARGET }}-v${{ env.CACHE_VERSION }}
          restore-keys: |
            macos-${{ matrix.arch }}-libs-

      - name: Build codec libraries
        if: steps.cache-libs.outputs.cache-hit != 'true'
        run: |
          set -e
          export PATH="$TARGET/bin:$PATH"
          export PKG_CONFIG_PATH="$TARGET/lib/pkgconfig"
          mkdir -p "$TARGET"/{include,lib,bin}
          mkdir -p "${{ github.workspace }}/ffmpeg_sources" && cd "${{ github.workspace }}/ffmpeg_sources"

          # Clean stale source directories from partial cache restore
          # (cache key changed, but old sources may still exist)
          rm -rf x264 x265_git libvpx aom aom_build opus-* lame-* nasm-*

          echo "=== Building nasm ==="
          # Use GitHub source archive (more reliable than nasm.us which often has connectivity issues)
          NASM_URL="https://github.com/netwide-assembler/nasm/archive/refs/tags/nasm-${{ env.NASM_VERSION }}.tar.gz"

          echo "Downloading NASM from GitHub..."
          curl -fSL --retry 3 --retry-delay 5 "$NASM_URL" -o nasm.tar.gz || {
            echo "ERROR: Failed to download NASM from $NASM_URL"
            exit 1
          }

          # SHA256 verification (hermetic build)
          echo "${{ env.NASM_SHA256 }}  nasm.tar.gz" | shasum -a 256 -c - || {
            echo "ERROR: NASM checksum verification failed!"
            echo "Expected: ${{ env.NASM_SHA256 }}"
            echo "Got:      $(shasum -a 256 nasm.tar.gz | cut -d' ' -f1)"
            exit 1
          }
          echo "NASM checksum verified"

          tar xzf nasm.tar.gz
          cd nasm-nasm-${{ env.NASM_VERSION }}
          # GitHub source archive requires autogen.sh to create configure script
          ./autogen.sh
          ./configure --prefix="$TARGET"
          make -j$(sysctl -n hw.ncpu)
          # GitHub source doesn't include pre-generated man pages (requires asciidoc)
          # Install binaries directly to avoid man page install failure
          mkdir -p "$TARGET/bin"
          install -c nasm ndisasm "$TARGET/bin/"
          cd ..

          echo "=== Building x264 (GPL) ==="
          git clone --depth 1 --branch ${{ env.X264_VERSION }} https://code.videolan.org/videolan/x264.git
          cd x264
          ./configure \
            --prefix="$TARGET" \
            --enable-static \
            --disable-shared \
            --enable-pic \
            --disable-cli \
            --extra-cflags="-arch $ARCH -mmacosx-version-min=${{ env.MACOS_DEPLOYMENT_TARGET }}" \
            --extra-ldflags="-arch $ARCH -mmacosx-version-min=${{ env.MACOS_DEPLOYMENT_TARGET }}"
          make -j$(sysctl -n hw.ncpu)
          make install
          cd ..

          echo "=== Building x265 (GPL) ==="
          git clone --depth 1 https://bitbucket.org/multicoreware/x265_git.git
          mkdir -p x265_git/build/xcode && cd x265_git/build/xcode
          cmake \
            -DCMAKE_INSTALL_PREFIX="$TARGET" \
            -DLIB_INSTALL_DIR="$TARGET/lib" \
            -DENABLE_SHARED=OFF \
            -DENABLE_CLI=OFF \
            -DCMAKE_OSX_ARCHITECTURES=$ARCH \
            -DCMAKE_OSX_DEPLOYMENT_TARGET=${{ env.MACOS_DEPLOYMENT_TARGET }} \
            ../../source
          make -j$(sysctl -n hw.ncpu)
          make install
          # x265 cmake doesn't always install .pc file, create it manually
          mkdir -p "$TARGET/lib/pkgconfig"
          cat > "$TARGET/lib/pkgconfig/x265.pc" << PCEOF
          prefix=$TARGET
          exec_prefix=\${prefix}
          libdir=\${prefix}/lib
          includedir=\${prefix}/include

          Name: x265
          Description: H.265/HEVC video encoder
          Version: 3.6
          Libs: -L\${libdir} -lx265
          Libs.private: -lc++ -lm -lpthread
          Cflags: -I\${includedir}
          PCEOF
          cd ../../..

          echo "=== Building libvpx (BSD) ==="
          git clone --depth 1 --branch ${{ env.LIBVPX_VERSION }} https://chromium.googlesource.com/webm/libvpx.git
          cd libvpx
          # Get Darwin version for target string (macOS 15 = Darwin 24)
          DARWIN_VERSION=$(uname -r | cut -d. -f1)
          if [ "$ARCH" = "arm64" ]; then
            VPX_TARGET="arm64-darwin${DARWIN_VERSION}-gcc"
          else
            VPX_TARGET="x86_64-darwin${DARWIN_VERSION}-gcc"
          fi
          echo "Using libvpx target: $VPX_TARGET"
          # IMPORTANT: Must pass extra-cflags to override the target's default
          # deployment target. libvpx uses darwin${DARWIN_VERSION} which embeds
          # the host macOS version (e.g., darwin24 for macOS 15), but we need
          # to target macOS 11.0 for ABI compatibility with binding.gyp.
          # NOTE: libvpx only supports --extra-cflags, NOT --extra-ldflags.
          # LDFLAGS must be passed as an environment variable.
          LDFLAGS="-mmacosx-version-min=${{ env.MACOS_DEPLOYMENT_TARGET }}" \
          ./configure \
            --prefix="$TARGET" \
            --target=$VPX_TARGET \
            --enable-vp8 \
            --enable-vp9 \
            --disable-examples \
            --disable-unit-tests \
            --enable-vp9-highbitdepth \
            --enable-static \
            --disable-shared \
            --extra-cflags="-mmacosx-version-min=${{ env.MACOS_DEPLOYMENT_TARGET }}"
          make -j$(sysctl -n hw.ncpu)
          make install
          cd ..

          echo "=== Building libaom (AV1, BSD) ==="
          git clone --depth 1 --branch ${{ env.LIBAOM_VERSION }} https://aomedia.googlesource.com/aom
          mkdir aom_build && cd aom_build
          cmake \
            -DCMAKE_INSTALL_PREFIX="$TARGET" \
            -DBUILD_SHARED_LIBS=OFF \
            -DENABLE_DOCS=OFF \
            -DENABLE_EXAMPLES=OFF \
            -DENABLE_TESTS=OFF \
            -DCMAKE_OSX_ARCHITECTURES=$ARCH \
            -DCMAKE_OSX_DEPLOYMENT_TARGET=${{ env.MACOS_DEPLOYMENT_TARGET }} \
            ../aom
          make -j$(sysctl -n hw.ncpu)
          make install
          cd ..

          echo "=== Building libopus (BSD) ==="
          curl -fSL --retry 3 https://downloads.xiph.org/releases/opus/opus-${{ env.OPUS_VERSION }}.tar.gz -o opus.tar.gz || {
            echo "ERROR: Failed to download Opus from xiph.org"
            exit 1
          }

          # SHA256 verification (hermetic build)
          echo "${{ env.OPUS_SHA256 }}  opus.tar.gz" | shasum -a 256 -c - || {
            echo "ERROR: Opus checksum verification failed!"
            echo "Expected: ${{ env.OPUS_SHA256 }}"
            echo "Got:      $(shasum -a 256 opus.tar.gz | cut -d' ' -f1)"
            exit 1
          }
          echo "Opus checksum verified"

          tar xzf opus.tar.gz
          cd opus-${{ env.OPUS_VERSION }}
          ./configure \
            --prefix="$TARGET" \
            --disable-shared \
            --enable-static \
            CFLAGS="-arch $ARCH -mmacosx-version-min=${{ env.MACOS_DEPLOYMENT_TARGET }}" \
            LDFLAGS="-arch $ARCH -mmacosx-version-min=${{ env.MACOS_DEPLOYMENT_TARGET }}"
          make -j$(sysctl -n hw.ncpu)
          make install
          cd ..

          echo "=== Building libmp3lame (LGPL) ==="
          curl -fSL --retry 3 "https://downloads.sourceforge.net/project/lame/lame/${{ env.LAME_VERSION }}/lame-${{ env.LAME_VERSION }}.tar.gz" -o lame.tar.gz || {
            echo "ERROR: Failed to download LAME from SourceForge"
            exit 1
          }

          # SHA256 verification (hermetic build)
          echo "${{ env.LAME_SHA256 }}  lame.tar.gz" | shasum -a 256 -c - || {
            echo "ERROR: LAME checksum verification failed!"
            echo "Expected: ${{ env.LAME_SHA256 }}"
            echo "Got:      $(shasum -a 256 lame.tar.gz | cut -d' ' -f1)"
            exit 1
          }
          echo "LAME checksum verified"

          tar xzf lame.tar.gz
          cd lame-${{ env.LAME_VERSION }}
          ./configure \
            --prefix="$TARGET" \
            --disable-shared \
            --enable-static \
            --enable-nasm \
            CFLAGS="-arch $ARCH -mmacosx-version-min=${{ env.MACOS_DEPLOYMENT_TARGET }}" \
            LDFLAGS="-arch $ARCH -mmacosx-version-min=${{ env.MACOS_DEPLOYMENT_TARGET }}"
          make -j$(sysctl -n hw.ncpu)
          make install
          cd ..

      - name: Build FFmpeg
        run: |
          set -e
          export PATH="$TARGET/bin:$PATH"
          export PKG_CONFIG_PATH="$TARGET/lib/pkgconfig"

          mkdir -p "${{ github.workspace }}/ffmpeg_sources"
          cd "${{ github.workspace }}/ffmpeg_sources"

          # Clone if not cached (use GitHub mirror - more reliable than git.ffmpeg.org)
          if [ ! -d ffmpeg ]; then
            for i in 1 2 3; do
              git clone --depth 1 https://github.com/FFmpeg/FFmpeg.git ffmpeg && break
              echo "Clone attempt $i failed, retrying in 10s..."
              sleep 10
            done
            # Verify clone succeeded
            if [ ! -d ffmpeg ]; then
              echo "ERROR: Failed to clone FFmpeg after 3 attempts"
              exit 1
            fi
          fi

          cd ffmpeg

          # Clean previous builds
          make distclean 2>/dev/null || true

          ./configure \
            --cc="clang -arch $ARCH" \
            --prefix="$TARGET" \
            --extra-cflags="-I$TARGET/include -fno-stack-check -mmacosx-version-min=${{ env.MACOS_DEPLOYMENT_TARGET }}" \
            --extra-ldflags="-L$TARGET/lib -mmacosx-version-min=${{ env.MACOS_DEPLOYMENT_TARGET }}" \
            --pkg-config-flags="--static" \
            --enable-static \
            --disable-shared \
            --enable-gpl \
            --enable-version3 \
            --enable-pthreads \
            --enable-runtime-cpudetect \
            --disable-ffplay \
            --disable-doc \
            --disable-debug \
            --enable-libx264 \
            --enable-libx265 \
            --enable-libvpx \
            --enable-libaom \
            --enable-libopus \
            --enable-libmp3lame

          make -j$(sysctl -n hw.ncpu)
          make install

      - name: Verify macOS deployment targets
        run: |
          export FFMPEG_ROOT="$TARGET"
          node scripts/check-macos-abi.cjs

      - name: Verify and strip binaries
        run: |
          echo "=== Checking dynamic library dependencies ==="
          otool -L "$TARGET/bin/ffmpeg"

          # Should only show /usr/lib/libSystem.B.dylib
          DEPS=$(otool -L "$TARGET/bin/ffmpeg" | grep -v libSystem | grep -v ":" | wc -l)
          if [ "$DEPS" -gt 0 ]; then
            echo "Warning: Found unexpected dynamic dependencies"
            otool -L "$TARGET/bin/ffmpeg" | grep -v libSystem | grep -v ":"
          fi

          echo "=== Stripping debug symbols ==="
          strip "$TARGET/bin/ffmpeg"
          strip "$TARGET/bin/ffprobe"

          echo "=== Binary sizes ==="
          ls -lh "$TARGET/bin/ffmpeg" "$TARGET/bin/ffprobe"

          echo "=== Version info ==="
          "$TARGET/bin/ffmpeg" -version

      - name: Package artifacts
        run: |
          mkdir -p artifacts/darwin-${{ matrix.arch }}/{bin,lib,include}

          # Copy binaries
          cp "$TARGET/bin/ffmpeg" artifacts/darwin-${{ matrix.arch }}/bin/
          cp "$TARGET/bin/ffprobe" artifacts/darwin-${{ matrix.arch }}/bin/
          "$TARGET/bin/ffmpeg" -version > artifacts/darwin-${{ matrix.arch }}/version.txt 2>&1 || true

          # Copy development files (needed for native addon compilation)
          cp -r "$TARGET/lib/"* artifacts/darwin-${{ matrix.arch }}/lib/
          cp -r "$TARGET/include/"* artifacts/darwin-${{ matrix.arch }}/include/

          # Verify dev files copied
          echo "=== Library files ==="
          ls -la artifacts/darwin-${{ matrix.arch }}/lib/
          echo "=== Pkgconfig files ==="
          ls -la artifacts/darwin-${{ matrix.arch }}/lib/pkgconfig/

          cd artifacts
          tar -cvf darwin-${{ matrix.arch }}.tar darwin-${{ matrix.arch }}/

      - name: Upload artifact
        uses: actions/upload-artifact@v6
        with:
          name: ffmpeg-darwin-${{ matrix.arch }}
          path: artifacts/darwin-${{ matrix.arch }}.tar
          retention-days: 7
          compression-level: 0

  # ============================================================================
  # Package npm modules
  # ============================================================================
  package-npm:
    name: Package npm modules
    runs-on: ubuntu-24.04
    needs: [build-linux-x64, build-macos]
    permissions:
      contents: read

    steps:
      - name: Checkout
        uses: actions/checkout@v6

      - name: Setup Node.js
        uses: actions/setup-node@v6
        with:
          node-version: '22'
          registry-url: 'https://registry.npmjs.org'

      - name: Download all artifacts
        uses: actions/download-artifact@v6
        with:
          pattern: ffmpeg-*
          path: artifacts

      - name: Extract and organize binaries
        run: |
          set -e

          # Extract tarballs
          for artifact in artifacts/ffmpeg-*/; do
            tarball=$(find "$artifact" -name "*.tar" | head -1)
            if [ -n "$tarball" ]; then
              echo "Extracting $tarball"
              tar -xvf "$tarball" -C "$artifact"
            fi
          done

          # Debug: show structure
          echo "=== Artifact structure ==="
          find artifacts -type f -name "ffmpeg*" -o -name "version.txt" | head -50

          # Create platform package directories
          mkdir -p packages

          # Dynamically discover platforms from downloaded artifacts
          # This avoids hardcoding platform names and makes the workflow more maintainable
          for artifact_dir in artifacts/ffmpeg-*/; do
            # Extract platform from artifact directory name (ffmpeg-linux-x64 -> linux-x64)
            platform=$(basename "$artifact_dir" | sed 's/ffmpeg-//')

            # Source directory is artifact_dir/platform/ (e.g., artifacts/ffmpeg-linux-x64/linux-x64/)
            src_dir="${artifact_dir}${platform}"

            # Binaries are now in bin/ subdirectory
            if [ ! -d "$src_dir" ] || [ ! -f "$src_dir/bin/ffmpeg" ]; then
              echo "Warning: Skipping $platform - source directory or binary not found at $src_dir/bin/ffmpeg"
              ls -laR "$src_dir" 2>/dev/null || echo "Directory doesn't exist"
              continue
            fi

            pkg_dir="packages/${{ env.NPM_SCOPE }}-${platform}"
            mkdir -p "$pkg_dir/bin"

            cp "$src_dir/bin/ffmpeg" "$pkg_dir/bin/"
            cp "$src_dir/bin/ffprobe" "$pkg_dir/bin/"
            chmod +x "$pkg_dir/bin/"*

            # Get version from tag or use 0.0.0-dev
            VERSION="${GITHUB_REF_NAME#v}"
            if [[ ! "$VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+(-[a-zA-Z0-9.-]+)?$ ]]; then
              VERSION="0.0.0-dev"
            fi

            # Create platform-specific package.json
            cat > "$pkg_dir/package.json" << EOF
          {
            "name": "${{ env.NPM_SCOPE }}-${platform}",
            "version": "${VERSION}",
            "description": "FFmpeg static binary for ${platform}",
            "os": ["$(echo $platform | cut -d'-' -f1 | sed 's/darwin/darwin/')"],
            "cpu": ["$(echo $platform | cut -d'-' -f2 | sed 's/x64/x64/;s/arm64/arm64/')"],
            "files": ["bin/"],
            "license": "GPL-2.0-or-later",
            "repository": {
              "type": "git",
              "url": "https://github.com/${{ github.repository }}"
            }
          }
          EOF

            # Fix os field
            if [[ "$platform" == darwin-* ]]; then
              sed -i 's/"os": \["darwin"\]/"os": ["darwin"]/' "$pkg_dir/package.json"
            else
              sed -i 's/"os": \["linux"\]/"os": ["linux"]/' "$pkg_dir/package.json"
            fi

            echo "Created package: $pkg_dir"
            cat "$pkg_dir/package.json"
          done

      - name: Create main package
        run: |
          VERSION="${GITHUB_REF_NAME#v}"
          if [[ ! "$VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+(-[a-zA-Z0-9.-]+)?$ ]]; then
            VERSION="0.0.0-dev"
          fi

          mkdir -p packages/${{ env.NPM_SCOPE }}

          cat > packages/${{ env.NPM_SCOPE }}/package.json << EOF
          {
            "name": "${{ env.NPM_SCOPE }}",
            "version": "${VERSION}",
            "description": "FFmpeg static binaries for Node.js",
            "main": "index.js",
            "types": "index.d.ts",
            "scripts": {
              "postinstall": "node install.js"
            },
            "optionalDependencies": {
              "${{ env.NPM_SCOPE }}-linux-x64": "${VERSION}",
              "${{ env.NPM_SCOPE }}-darwin-x64": "${VERSION}",
              "${{ env.NPM_SCOPE }}-darwin-arm64": "${VERSION}"
            },
            "license": "GPL-2.0-or-later",
            "repository": {
              "type": "git",
              "url": "https://github.com/${{ github.repository }}"
            },
            "keywords": ["ffmpeg", "video", "audio", "encoding", "webcodecs"],
            "engines": {
              "node": ">=16"
            }
          }
          EOF

          # Create index.js with binary resolution
          cat > packages/${{ env.NPM_SCOPE }}/index.js << 'EOF'
          const path = require('path');
          const { execSync, spawn } = require('child_process');

          const PLATFORMS = {
            'darwin-arm64': '${{ env.NPM_SCOPE }}-darwin-arm64',
            'darwin-x64': '${{ env.NPM_SCOPE }}-darwin-x64',
            'linux-x64': '${{ env.NPM_SCOPE }}-linux-x64',
          };

          function getBinaryPath(binary = 'ffmpeg') {
            const platform = `${process.platform}-${process.arch}`;
            const pkg = PLATFORMS[platform];

            if (!pkg) {
              throw new Error(
                `Unsupported platform: ${platform}. ` +
                `Supported: ${Object.keys(PLATFORMS).join(', ')}`
              );
            }

            try {
              const pkgPath = require.resolve(`${pkg}/package.json`);
              return path.join(path.dirname(pkgPath), 'bin', binary);
            } catch (e) {
              throw new Error(
                `Binary package ${pkg} not found. ` +
                `Run: npm install --include=optional`
              );
            }
          }

          function ffmpeg(args, options = {}) {
            const binary = getBinaryPath('ffmpeg');
            if (typeof args === 'string') {
              return execSync(`"${binary}" ${args}`, { encoding: 'utf8', ...options });
            }
            return spawn(binary, args, options);
          }

          function ffprobe(args, options = {}) {
            const binary = getBinaryPath('ffprobe');
            if (typeof args === 'string') {
              return execSync(`"${binary}" ${args}`, { encoding: 'utf8', ...options });
            }
            return spawn(binary, args, options);
          }

          module.exports = {
            getBinaryPath,
            ffmpegPath: getBinaryPath('ffmpeg'),
            ffprobePath: getBinaryPath('ffprobe'),
            ffmpeg,
            ffprobe,
          };
          EOF

          # Create TypeScript definitions
          cat > packages/${{ env.NPM_SCOPE }}/index.d.ts << 'EOF'
          import { SpawnOptions, ChildProcess, ExecSyncOptions } from 'child_process';

          export function getBinaryPath(binary?: 'ffmpeg' | 'ffprobe'): string;
          export const ffmpegPath: string;
          export const ffprobePath: string;

          export function ffmpeg(args: string, options?: ExecSyncOptions): string;
          export function ffmpeg(args: string[], options?: SpawnOptions): ChildProcess;

          export function ffprobe(args: string, options?: ExecSyncOptions): string;
          export function ffprobe(args: string[], options?: SpawnOptions): ChildProcess;
          EOF

          # Create install verification script
          cat > packages/${{ env.NPM_SCOPE }}/install.js << 'EOF'
          const { getBinaryPath } = require('./index');
          const { execSync } = require('child_process');

          try {
            const ffmpegPath = getBinaryPath('ffmpeg');
            const version = execSync(`"${ffmpegPath}" -version`, { encoding: 'utf8' });
            console.log('FFmpeg binary verified:', ffmpegPath);
            console.log(version.split('\n')[0]);
          } catch (e) {
            console.warn('Warning: FFmpeg binary not found for this platform');
            console.warn(e.message);
          }
          EOF

      - name: Upload packaged artifacts
        uses: actions/upload-artifact@v6
        with:
          name: npm-packages
          path: packages/
          retention-days: 7

  # ============================================================================
  # Publish to npm (only on tag push)
  # ============================================================================
  publish-npm:
    name: Publish to npm
    runs-on: ubuntu-24.04
    needs: [package-npm]
    if: startsWith(github.ref, 'refs/tags/v') && !inputs.skip_publish
    permissions:
      contents: read
      id-token: write  # Required for npm provenance

    environment:
      name: npm
      url: https://www.npmjs.com/package/${{ env.NPM_SCOPE }}

    steps:
      - name: Setup Node.js
        uses: actions/setup-node@v6
        with:
          node-version: '22'
          registry-url: 'https://registry.npmjs.org'

      - name: Download npm packages
        uses: actions/download-artifact@v6
        with:
          name: npm-packages
          path: packages

      - name: Publish platform packages
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}
        run: |
          set -e

          # Publish platform-specific packages first
          for pkg in packages/${{ env.NPM_SCOPE }}-*/; do
            echo "Publishing $pkg"
            cd "$pkg"
            npm publish --access public --provenance
            cd - > /dev/null
          done

          # Wait for registry propagation
          sleep 10

          # Publish main package
          echo "Publishing main package"
          cd "packages/${{ env.NPM_SCOPE }}"
          npm publish --access public --provenance

  # ============================================================================
  # Create GitHub Release
  # ============================================================================
  release:
    name: Create GitHub Release
    runs-on: ubuntu-24.04
    needs: [build-linux-x64, build-macos]
    if: startsWith(github.ref, 'refs/tags/v')
    permissions:
      contents: write

    steps:
      - name: Download all artifacts
        uses: actions/download-artifact@v6
        with:
          pattern: ffmpeg-*
          path: artifacts

      - name: Prepare release assets
        run: |
          mkdir -p release

          # Extract and repackage with better names
          # NOTE: End users expect binaries at root level, not in bin/ subdirectory
          for artifact in artifacts/ffmpeg-*/; do
            tarball=$(find "$artifact" -name "*.tar" | head -1)
            if [ -n "$tarball" ]; then
              platform=$(basename "$artifact" | sed 's/ffmpeg-//')
              tar -xf "$tarball" -C artifacts/

              # Flatten structure for end users: move bin/* to root level
              # (Internal artifacts have bin/, lib/, include/ but users just want binaries)
              if [ -d "artifacts/${platform}/bin" ]; then
                mv "artifacts/${platform}/bin/ffmpeg" "artifacts/${platform}/ffmpeg"
                mv "artifacts/${platform}/bin/ffprobe" "artifacts/${platform}/ffprobe"
                rm -rf "artifacts/${platform}/bin" "artifacts/${platform}/lib" "artifacts/${platform}/include"
              fi

              # Create release tarball with version
              cd artifacts
              tar -czvf "../release/ffmpeg-${GITHUB_REF_NAME}-${platform}.tar.gz" "${platform}/"
              cd ..
            fi
          done

          ls -la release/

      - name: Create Release
        uses: softprops/action-gh-release@v2.2.1
        with:
          files: release/*
          generate_release_notes: true
          body: |
            ## FFmpeg Static Binaries

            This release includes statically linked FFmpeg binaries for:
            - Linux x64 (musl libc, fully static)
            - macOS x64 (Intel)
            - macOS arm64 (Apple Silicon)

            ### Included Codecs
            - H.264 (libx264) - GPL
            - H.265/HEVC (libx265) - GPL
            - VP8/VP9 (libvpx) - BSD
            - AV1 (libaom) - BSD
            - Opus (libopus) - BSD
            - MP3 (libmp3lame) - LGPL

            ### npm Installation
            ```bash
            npm install ${{ env.NPM_SCOPE }}
            ```

            ### License
            These binaries are licensed under GPL v2+ due to the inclusion of libx264 and libx265.

  # ============================================================================
  # Create Dependencies Release (for CI/build-prebuilds consumption)
  # ============================================================================
  # This job creates the deps-vN release that ci.yml and build-prebuilds.yml
  # download FFmpeg binaries from. Files are named without version prefix:
  #   ffmpeg-linux-x64.tar.gz (not ffmpeg-v1.0.0-linux-x64.tar.gz)
  # ============================================================================
  release-deps:
    name: Create Dependencies Release
    runs-on: ubuntu-24.04
    needs: [build-linux-x64, build-linux-x64-glibc, build-macos]
    # Run if: manually triggered with deps_version input OR tag push matches deps-*
    if: inputs.deps_version != '' || startsWith(github.ref, 'refs/tags/deps-')
    permissions:
      contents: write

    steps:
      - name: Download all artifacts
        uses: actions/download-artifact@v6
        with:
          pattern: ffmpeg-*
          path: artifacts

      - name: Determine deps version
        id: version
        run: |
          if [ -n "${{ inputs.deps_version }}" ]; then
            # Manual trigger with input
            VERSION="${{ inputs.deps_version }}"
          else
            # Tag push (deps-v1 -> v1)
            VERSION="${GITHUB_REF_NAME#deps-}"
          fi
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Using deps version: $VERSION"

      - name: Prepare deps release assets
        run: |
          mkdir -p release

          # Extract artifacts and create unversioned tarballs
          # IMPORTANT: build-prebuilds.yml expects files at root level (lib/, include/, bin/)
          # NOT inside a platform subdirectory
          for artifact in artifacts/ffmpeg-*/; do
            tarball=$(find "$artifact" -name "*.tar" | head -1)
            if [ -n "$tarball" ]; then
              platform=$(basename "$artifact" | sed 's/ffmpeg-//')
              echo "Processing platform: $platform"

              # Extract the tar (contains platform/ directory with bin/, lib/, include/)
              tar -xf "$tarball" -C artifacts/

              # Verify expected structure exists
              if [ ! -d "artifacts/${platform}/lib" ]; then
                echo "ERROR: Missing lib/ directory for $platform"
                ls -laR "artifacts/${platform}/"
                exit 1
              fi

              # Make .pc files relocatable by replacing hardcoded paths with ${prefix}
              # FFmpeg and some dependencies embed absolute paths in Libs/Cflags,
              # so rewrite them to use ${prefix} for relocation via pkg-config.
              echo "Making .pc files relocatable for $platform..."
              for pc_file in "artifacts/${platform}/lib/pkgconfig/"*.pc; do
                if [ -f "$pc_file" ]; then
                  # Get the original prefix from the file
                  original_prefix=$(grep "^prefix=" "$pc_file" | cut -d= -f2)
                  if [ -n "$original_prefix" ]; then
                    # Replace hardcoded libdir and includedir with ${prefix} variables
                    sed -i.bak \
                      -e "s|^libdir=${original_prefix}/lib|libdir=\${prefix}/lib|" \
                      -e "s|^includedir=${original_prefix}/include|includedir=\${prefix}/include|" \
                      -e "s|^libdir=${original_prefix}|libdir=\${prefix}|" \
                      -e "s|^includedir=${original_prefix}|includedir=\${prefix}|" \
                      -e "/^prefix=/! s|${original_prefix}|\\\${prefix}|g" \
                      "$pc_file"
                    rm -f "${pc_file}.bak"
                  fi
                fi
              done

              # Create release tarball with files at ROOT level (not inside platform subdir)
              # This is what build-prebuilds.yml expects when it does:
              #   tar -xzvf ffmpeg-darwin-arm64.tar.gz -C ffmpeg-install
              #   ls -la ffmpeg-install/lib/
              cd "artifacts/${platform}"
              tar -czvf "../../release/ffmpeg-${platform}.tar.gz" lib/ include/ bin/ version.txt
              cd ../..
            fi
          done

          echo "=== Release assets ==="
          ls -la release/

          # Verify all expected platforms present and have correct structure
          for platform in linux-x64 linux-x64-glibc darwin-x64 darwin-arm64; do
            if [ ! -f "release/ffmpeg-${platform}.tar.gz" ]; then
              echo "ERROR: Missing ffmpeg-${platform}.tar.gz"
              exit 1
            fi
            # Verify tarball contents
            echo "=== Contents of ffmpeg-${platform}.tar.gz ==="
            tar -tzf "release/ffmpeg-${platform}.tar.gz" | head -20
          done
          echo "All platform artifacts verified."

      - name: Create Dependencies Release
        uses: softprops/action-gh-release@v2.2.1
        with:
          tag_name: deps-${{ steps.version.outputs.version }}
          name: FFmpeg Dependencies ${{ steps.version.outputs.version }}
          files: release/*
          body: |
            ## FFmpeg Static Libraries for CI

            This release contains FFmpeg static binaries used by the CI and build pipelines.
            **Do not use directly** - these are consumed by `ci.yml` and `build-prebuilds.yml`.

            ### Files
            - `ffmpeg-linux-x64.tar.gz` - Linux x64 (musl, fully static binaries)
            - `ffmpeg-linux-x64-glibc.tar.gz` - Linux x64 (glibc, for native addon linking)
            - `ffmpeg-darwin-x64.tar.gz` - macOS Intel
            - `ffmpeg-darwin-arm64.tar.gz` - macOS Apple Silicon

            **Note:** `build-prebuilds.yml` uses `linux-x64-glibc` for native addon builds because
            musl-compiled static libraries cannot be linked into shared objects on glibc systems.

            ### Codec Versions
            - FFmpeg: ${{ env.FFMPEG_VERSION }}
            - x264: ${{ env.X264_VERSION }}
            - x265: ${{ env.X265_VERSION }}
            - libvpx: ${{ env.LIBVPX_VERSION }}
            - libaom: ${{ env.LIBAOM_VERSION }}
            - opus: ${{ env.OPUS_VERSION }}
            - lame: ${{ env.LAME_VERSION }}

            ### Usage
            Update `DEPS_VERSION` in `ci.yml` and `build-prebuilds.yml` to use this release:
            ```yaml
            env:
              DEPS_VERSION: ${{ steps.version.outputs.version }}
            ```
